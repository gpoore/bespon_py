\documentclass[11pt]{article}

\usepackage[T1]{fontenc}
\usepackage{fourier}

\usepackage[margin=1in]{geometry}

\usepackage{amsmath, amssymb}
\usepackage{fvextra}

\usepackage[svgnames]{xcolor}
\usepackage{tcolorbox}

\usepackage{multicol}

\usepackage[toc,page]{appendix}


\usepackage{hyperref}
\hypersetup{colorlinks=true,urlcolor=Green,linkcolor=Green}
\usepackage{cleveref}


\makeatletter
\let\orig@footnote\footnote
\renewcommand{\footnote}{%
  \begingroup
  \let\do\@makeother
  \dospecials
  \catcode`\{=1
  \catcode`\}=2
  \new@footnote}
\newcommand{\new@footnote}[1]{%
  \endgroup
  \orig@footnote{\scantokens{#1}}}

\newcommand{\bespon}{BespON}
\newcommand{\besponfull}{Bespoken Object Notation}

\DefineShortVerb[formatcom=\color{DarkRed}]{\|}
\RecustomVerbatimEnvironment{Verbatim}{Verbatim}{formatcom=\color{DarkRed}}
\renewenvironment{verbatim}{\VerbatimEnvironment\begin{Verbatim}}{\end{Verbatim}}

\newcommand{\verbpipe}{\textcolor{DarkRed}{\texttt{\string|}}}

\newcommand{\meta}[1]{\ensuremath{\langle}\textit{#1}\ensuremath{\rangle}}
\newcommand{\vmeta}[1]{{\color{DarkRed}\ensuremath{\langle}\textit{#1}\ensuremath{\rangle}}}
\makeatletter
\newcommand{\lit}{%
  \begingroup
  \let\do\@makeother
  \dospecials
  \catcode`\{=1
  \catcode`\}=2
  \lit@i}
\def\lit@i#1{%
  \endgroup
  \texttt{\color{DarkRed}\detokenize{#1}}}
\makeatother

\newcommand{\darrow}{\ensuremath{\textcolor{DarkGreen}{\downarrow}}}

\newcommand{\note}[1]{\textcolor{red}{#1}}


\title{\textbf{\bespon} \\ \besponfull}
\author{Geoffrey M.\ Poore}
\date{\today}


\begin{document}

\maketitle


\begin{abstract}
\bespon\ is a text-based, human-friendly, extensible configuration language.  Data may be represented in a compact inline form, an indentation-based form, or a section- and keypath-based form.
\end{abstract}


\pagebreak
\tableofcontents
\pagebreak


\section{Motivation}

Almost simultaneously, several of my programming projects reached a point where some sort of configuration was required.  \besponfull\ (\bespon) is the result of my dissatisfaction with existing configuration formats.

The creation of new formats is often criticized (requisite \href{https://xkcd.com/927/}{XKCD reference}), and this criticism is often legitimate.  At the same time, if there are never any new formats, then we will never get better tools.  Here is my motivation for creating \bespon, instead of using an established format like \href{http://www.json.org/}{JSON} or \href{http://yaml.org/}{YAML}, or a more recent format like \href{https://github.com/toml-lang/toml}{TOML}.


\begin{description}
\item[Comments]  JSON doesn't allow them, but they are useful in configuration.

\item[Round-tripping]  If there are going to be comments, we better be able to round-trip them, at least in simple cases.  Otherwise, we will always have to update configuration by hand.  Most formats that do have comments have few if any implementations that round-trip comments.  While we're at it, we might as well be able to round-trip exact layout, including whitespace and indentation---again, at least for simple cases.

\item[Trailing commas]  JSON doesn't allow |{"k": "v",}|.

\item[Multiline strings]  JSON requires an entire string to be on a single line, with newlines represented as |\n|.  That's painful for configuration.

YAML has block literals that begin with \verbpipe.  That's an improvement until you need text with leading whitespace or trailing empty lines.  Then you have to resort to things like this (visible space characters):
\begin{Verbatim}[showspaces]
key1: |6+
          First line, indented four spaces
        Second line, indented two spaces, followed by empty line

key2: value...
\end{Verbatim}
The |6| after the \verbpipe\ indicates that the text is indented by six spaces \emph{relative to the indentation} of |key1|, and the |+| means that trailing empty lines should be kept rather than discarded (which makes the string content dependent on the relative position of |key2|).  The result is text with literal newlines with an overall indentation of two spaces but a first line indented by four spaces, and with a trailing empty line consisting of |\n|.

TOML has triple-quoted strings that preserve newlines.  This allows trailing empty lines to be clearly indicated.  It also allows clear indication of indentation, but with the significant disadvantage that \emph{any} indentation is counted as part of the string; the string literal itself cannot be indented without the indentation becoming part of the actual string content.  This is a common problem with multiline string literals.

\item[Both integers and (proper) floats]  JSON just has a number type, with no |inf| or |nan|.  TOML has both integers and floats, but lacks |inf| and |nan|.  If we're going to have separate integers and floats, we might as well have decimal, hex, octal, and binary integer literals, and decimal and hex float literals.  At the same time, all of this should be handled sensibly for languages such as JavaScript and Perl that lack an integer type.

\item[Explicit typing for custom types]  JSON and TOML have no support for special or user-defined types unless a convention is agreed upon or unless an implementation provides features beyond the specification.  They lack a notation for explicitly indicating type information for custom types.

\item[Unquoted strings]  It would be convenient to omit quotation marks, at least in simple cases.  But since that increases the potential for ambiguity with keywords and implicit typing, it should be possible to require quoting.

\item[Strict reserved words]  If unquoted strings are allowed, the potential for ambiguity between reserved words and strings increases.  Reserved words should only be allowed to appear in a form with accepted capitalization; appearance with any other capitalization should trigger an error.  In contrast, YAML's |True| is boolean true, but |TRue| is the string |TRue|.  Also, the list of reserved words should be minimal.  No YAML |yes|/|no| |on|/|off| |true|/|false|.

\item[Unique keys] JSON permits duplicate keys.  The YAML spec says that keys must be unique.  Parsers for both JSON and YAML commonly allow later keys to overwrite earlier keys.  TOML prohibits duplicate keys.  Key overwriting should be prohibited, but there should be a way to copy data structures to provide an alternative to overwriting.  Undefined or ambiguous behavior, whether due to specification or implementation, is unacceptable.

\item[A small list of special characters] In YAML, almost all non-alphanumeric ASCII characters have a special meaning, which is context-dependent in many cases.  For example, |#| starts a comment, but only if preceded by a whitespace character.  The number of special characters should be kept to an easy-to-remember minimum, and as far as possible, they should not be context-dependent.  

\item[Simple representation of deeply nested data structures]  TOML has INI-style sections that allow keypaths of the form |key.subkey.subsubkey|.  This provides a convenient, compact representation of nested dictionaries.  A similar syntax is needed that also allows some elements in the path to be lists rather than dictionaries, so that arbitrary nested data structures may be represented in a compact manner.

\item[Labels, aliases, and copying]  For convenient configuration, it should be possible to label data structures and then create aliases to them or copy them later.  Both deep and shallow copies should be possible.  Copying provides most of the advantages of overwriting with less of the complexity and potential for errors or unintended consequences.

\item[Decent performance even when completely implemented in an interpreted language]  Pure Python implementations of YAML have a reputation for being slow.  It should be possible to implement \bespon\ in Python and other interpreted languages while achieving decent performance.  This will simplify the process of creating implementations for multiple languages, and should promote broader adoption.
\end{description}




\section{Terminology}

The words \textit{may}, \textit{should}, and \textit{must} in the description below are interpreted according to \href{http://www.ietf.org/rfc/rfc2119.txt}{RFC 2119}.




\section{Encoding and code points}

\bespon\ is specified at the level of Unicode strings.

In loading data, an implementation is only responsible for what it does with what it receives.  When an implementation receives a Unicode string or stream, the implementation is not responsible for any transformations performed on the string or stream during any decoding or normalization steps before it was received.  However, the implementation's documentation should mention any decoding or normalization steps that might reasonably be expected before the string or stream is received, if these might alter the interpretation of the data.

When an implementation receives a binary string or stream, it must decode the string or stream as UTF-8 unless an encoding is specified.  Regardless of whether an implementation receives a Unicode or binary string or stream, it must check for a Unicode byte-order mark (BOM), and discard it if present.

Once data is in the form of a Unicode string or stream, by default it must be validated according to the following procedure before processing.  Implementations may choose to validate all at once before processing or a chunk at a time during processing.  An implementation may provide an option that allows a less strict validation (allows some or all disallowed code points to appear as literals), but this must not be the default.

\paragraph{Newline normalization}  The sequence |\r\n| (U+000D U+000A) must be normalized to |\n| (U+000A).  

\paragraph{Disallowed code points}  The string or stream must be checked for code points that are not allowed.  These code points may be represented in escaped form, but must not appear literally.  The presence of any of these code points must result in an error.
\begin{itemize}
\item All code points with Unicode category ``Other, Control'' (Cc)\footnote{``Other, Control'' includes the range U+0000 to U+001F (ord 0--31), the character U+007F (ord 127, ``DELETE''), and U+0080 to U+009F (ord 128--159).} are prohibited, with the exception of line feed U+000A (|\n|) and horizontal tab U+0009 (|\t|).  Note that any carriage returns U+000D (|\r|) not removed by newline normalization are not allowed.  These code points are prohibited because they may be invisible in some editors and because some control characters (such as the null byte) have security implications.

\item All code points treated as newlines in the Unicode Newline Guidelines (\href{http://unicode.org/standard/reports/tr13/tr13-5.html}{Unicode Technical Report \#13}) are prohibited, with the exception of line feed U+000A (|\n|).  This includes vertical tab U+000B (|\v|), form feed U+000C (|\f|), carriage returns U+000D (|\r|), and next line U+0085 (NEL), which are already covered under the ``Other, Control'' category.  It also includes line separator U+2028 and paragraph separator U+2029.  These characters are prohibited to ensure that newline treatment is uniform and to guarantee that the use of any newlines beyond line feed U+000A (|\n|) is explicit.

\item Two code points in the Unicode Bidi\_Control formatting characters must not appear as literals:  left-to-right override U+202D and right-to-left override U+202E.  Bidi override characters can be a security concern in general, and are particularly problematic in a configuration format designed for manual editing.  \href{http://unicode.org/reports/tr36/}{Unicode Technical Report \#36}, ``Unicode Security Considerations,'' recommends that overrides never be allowed in IRIs.

\item Unpaired UTF-16 surrogates (U+D800 -- U+DFFF) are prohibited.  In other words, all code points that are not Unicode scalar values are prohibited.
\end{itemize}
The list of disallowed code points is current as of Unicode 9.0.0 (2016-06-01).  Barring unforseen circumstances, the list will be expanded only under two conditions:  (1) additional newline code points are defined, or (2) additional code points are added (or existing code points are identified) that pose a security concern similar to that of the bidi overrides.

In dumping data, an implementation must by default ensure that the dumped data is valid for loading with a default configuration.  If an implementation dumps data in binary form, it must encode the data with UTF-8 unless an encoding is specified.  If an implementation encodes data to binary, it may convert |\n| to |\r\n| in a system-dependent manner during the encoding.




\section{Character class definitions}
The specification is defined in terms of several classes of characters.
\begin{description}
\item[Spaces:]  One or more of the space U+0020 \begingroup\fvset{showspaces}(| |)\endgroup.
\item[Indentation:]  One or more spaces or horizontal tabs U+0009 (|\t|).
\item[Newlines:]  One or more of the line feed U+000A (|\n|).
\item[Whitespace:]  A continuous run of indentation or newlines.
\item[Unicode whitespace:]  Unicode code points with the White\_Space property.  This covers the 25 code points U+0009 -- U+000D, U+0020, U+0085, U+00A0, U+1680, U+2000 -- U+200A, U+2028, U+2029, U+202F, U+205F, and U+3000.
\end{description}





\section{Core types}

\bespon\ defines core data types that must be defined in every implementation unless the implementation language lacks a comparable type.

If a language lacks an integer type, then by default it must interpret all integers as floats when loading data.  Implementations should provide an option to raise an error instead.  Such a language must only dump floats by default.  Implementations may provide a mechanism for the user to specify that some numbers are to be dumped as integers instead.  When \bespon\ is used as an interchange format between languages, and not all languages have integers, then it is recommended that all numbers be sent as floats, with explicit post-processing to integers as necessary.  A parser directive (\cref{sec:parser-directive}) may be used to enforce that all numbers are floats in a cross-language context.

If a language lacks any other core type and it is not practical to implement the missing type, then that type must be omitted.  An error must be raised whenever that type is encountered while loading data.  When dumping data, the missing type must not be dumped by default.


\paragraph{A brief summary of explicit typing}

Many types, such as integers, floats, and booleans, are implicitly typed.  All types are also given a type name for use in explicit typing; some types are only available through explicit typing.  The syntax for explicit typing is
\begin{Verbatim}[commandchars=\\\{\}]
(\meta{type})> \meta{quoted or unquoted string}
\end{Verbatim}
For example, |(float)> 1.23e4|.  In the discussion of types below, the type name for explicit typing is given in parentheses after the description of each type.  The syntax for explicit typing is also used to define advanced features; these are discussed in detail in \cref{sec:advanced-options}.


\subsection{Scalar types}

Scalar core types are core types that are not collections of other objects so far as \bespon\ is concerned.  For example, a programming language may treat strings as arrays or collections of code points or encoded bytes, but as far as \bespon\ is concerned, a string is a fundamental, indivisible type.


\subsubsection{None (null, nil, undef) (\texttt{none})}

The literal string |none|.  Any other capitalization of ``none'' must result in an error.  |none| is provided primarily for completeness; in practice, it is typically best avoided.


\subsubsection{Boolean (\texttt{bool})}

The literal strings |true| and |false|.  Any other capitalization of either must result in an error.


\subsubsection{Integer (\texttt{int})}

Integer literals may take decimal, hex, octal, or binary forms.  Single underscores are allowed to separate adjoining digits to aid visual parsing.

Integers are defined by the following regular expressions (whitespace insensitive).  Equivalent regexes may be substituted.
\begin{description}
\item[Decimal:]  \lit{[+-]?[\x20\t]*(?: 0 | [1-9](?:_[0-9]|[0-9])*) $}
\item[Hexadecimal:]  \lit{[+-]?[\x20\t]*0x[0-9a-fA-F](?:_[0-9a-fA-F]|[0-9a-fA-F])*$}
\item[Octal:]  \lit{[+-]?[\x20\t]*0o[0-7](?:_[0-7]|[0-7])*$}
\item[Binary:]  \lit{[+-]?[\x20\t]*0b[01](?:_[01]|[01])*$}
\end{description} %$ <- highlighting
Hex, octal, and binary integers must use lowercase |x|, |o|, and |b|.  Any string that would be an integer except for this capitalization must result in an error.  This prevents the confusable possibility of octal |0O|\vmeta{digits} while maintaining consistency across bases.  Integers must not have leading zeros; leading zeros must result in an error.  This prevents confusion with languages that use a leading zero to indicate octal values.

Integer precision is not specified, but a minimum of 32 bits is expected.  This allows the comfortable substitution of a 64-bit float in languages without an integer type.  Implementations must check for integer overflow when loading data, and raise an error if any integer cannot fit in the specified integer type.

In a format that does not require all strings to be quoted, there is a danger of confusing incorrect integer literals with unquoted strings.  If |1_234| becomes an integer, but |1__234| becomes a string, then manual editing can easily introduce errors.  This could be dealt with by having an extremely permissive syntax, so that even something like |1______234| becomes an integer; that is simple but not aesthetic.  The issue could also be dealt with by requiring that all unquoted strings begin with an identifier-style word that cannot start with a digit, perhaps something like |[a-zA-Z][a-zA-Z0-9]*|.  That has the disadvantage that things like numbers with units, such as |-12pt|, would require quoting.  Given some of the intended use cases for \bespon, that is unacceptable.

Instead, unquoted strings may begin with digits or an otherwise integer pattern, but after any starting sequence matched by the regex \lit{[+-]?[\x20\t]*(?:0x|0o|0b|[0-9])} such strings must not consist solely of characters that are allowed after this in the corresponding integer literal, with the additional restriction that |0o| and |0b| follow the same requirements as |0x|, and the additional restriction that the comma U+002C (|,|) is added to the list of checked code points to prevent ambiguity regarding thousands or decimal separators.  For example, an unquoted string that begins with |1| must contain something besides |[0-9_]+| after the |1|, and an unquoted string that begins with |0x| must contain something besides |[0-9a-fA-F_]+|.  This minimizes the potential for incorrect integers to be misinterpreted as strings while placing minimal limitations on unquoted string syntax.


\subsubsection{Float (\texttt{float})}

Float literals may take decimal or hexadecimal forms.  Hex form is convenient for avoiding small rounding errors upon round tripping.  As with integers, single underscores are allowed between adjacent digits.

Floats are defined by the following regular expressions (whitespace insensitive).  Equivalent regexes may be substituted.

\paragraph{Decimal:}
\begin{Verbatim}[fontsize=\small]
[+-]?[\x20\t]*
     (?: 0 | [1-9](?:_[0-9]|[0-9])*)
     (?: \. [0-9](?:_[0-9]|[0-9])* (?:[eE][+-]?[0-9](?:_[0-9]|[0-9])*)? |
         (?:[eE][+-]?[0-9](?:_[0-9]|[0-9])*) 
     ) $
\end{Verbatim}

\paragraph{Hexadecimal:}
\begin{Verbatim}[fontsize=\small]
[+-]?[\x20\t]* 
     0x [0-9a-fA-F](?:_[0-9a-fA-F]|[0-9a-fA-F])*
     (?: \.[0-9a-fA-F](?:_[0-9a-fA-F]|[0-9a-fA-F])* (?:[pP][+-]?[0-9](?:_[0-9]|[0-9])*)? |
         (?:[pP][+-]?[0-9](?:_[0-9]|[0-9])*)
     ) $
\end{Verbatim}
Leading zeros before the decimal point in decimal form and capital |X| in hexadecimal form are not allowed and must result in errors.  Both capital and lowercase |e| and |p| must be allowed in input, but lowercase should always be used in output.  A decimal point that is not immediately adjacent to a digit on both sides is prohibited.

Float precision is not specified, but a minimum of 64 bits with IEEE 754 compatibility is expected.  Implementations must raise an error if a value cannot fit in the specified float type.

The special float values |inf|, |\+[\x20\t]*inf|, |\-[\x20\t]*inf|, and |nan| are allowed.  An error must be raised if any of these appear with a different capitalization, or if any of these appear and are not supported by the specified float type.

Like integer literals, float literals should not be inadvertently converted into strings due to minor syntax errors.  Unquoted strings may begin with digits or an otherwise float pattern, but after any starting sequence matched by the regex \lit{[+-]?[\x20\t]*(?:0x|[.0-9])} such strings must not consist solely of characters that are allowed after this in the corresponding float literal, with the additional restriction that the comma U+002C (|,|) is added to the list of checked code points to prevent ambiguity regarding thousands or decimal separators.


\subsubsection{String (\texttt{str})}

Unicode strings may appear in several forms.

\paragraph{Unquoted strings}

By default, unquoted strings are allowed if (1) they contain only printable ASCII characters (U+0020 -- U+007E), (2) they do not include the special characters |%=,*'"{}[]()|, (3) they do not meet the pattern for any of the types described so far (|none|, |bool|, |int|, |float|), or patterns that are prohibited by the types described so far (invalid |int|-like or |float|-like, or invalid keyword capitalization).  When unquoted strings are used as dict keys, they must meet additional requirements (\cref{sec:type:dict}).

An unquoted string ends at the next character not allowed in an unquoted string, at the next line consisting only of whitespace, or at the next line with an indentation level that does not match that of the string, whichever is found first.  Leading and trailing whitespace are stripped from an unquoted string.  When characters outside the printable ASCII range are enabled in unquoted strings, strings must not begin or end with Unicode whitespace.

An unquoted string may contain |\n| to wrap it onto multiple lines.  When this is done, all lines must have the same indentation and must not begin with Unicode whitespace after common indentation is stripped, except that the first line may have different indentation if it is not at the beginning of the line (see indentation rules, \cref{sec:indentation}).  The string is unwrapped by removing common indentation and then stripping |\n| when preceded by Unicode whitespace and replacing |\n| with a space otherwise.

The behavior of unquoted strings may be modified with parser directives (\cref{sec:parser-directive}).  Unquoted strings may be disabled with a parser directive.  Unquoted Unicode characters beyond the ASCII range may also be enabled with a parser directive.  However, this is not the default behavior, since the full Unicode range contains many characters that closely resemble the special characters or are invisible or nearly invisible.  When the full Unicode range is enabled unquoted, it is easy to create text that appears to be a keyword or number, but actually contains other characters and thus will be treated as a string instead.


\paragraph{Quoted escaped strings}

Quoted escaped strings are quoted with double quotation marks U+0022 (|"|).  They allow code points to be represented with backslash escapes, including all code points that must not appear literally except for the UTF-16 surrogates.  An implementation in a language that allows unpaired surrogates in its Unicode strings may provide an option to allow escaped surrogates, but this must not be the default.  Backslash escapes use the hex notations |\xHH| (8-bit), |\uHHHH| (16-bit), and |\UHHHHHHHH| (32-bit), as well as |\u{H...H}| (hex value consisting of 1--6 characters).  The |\u{H...H}| notation should be preferred.

Common short escapes are also defined:  |\\|, |\'|, |\"|, |\a|, |\b|, |\e|, |\f|, |\n|, |\r|, |\t|, |\v|.  The escape |\/| should be allowed for cases when compatibility with JSON strings is desired.  The escape |\|\vmeta{optional\_spaces}|\n| is replaced with the empty string, so that a string containing no whitespace may be wrapped across multiple lines.

The exact behavior of a quoted escaped string depends on the quotation mark delimiters.
\begin{itemize}
\item A quoted escaped string that begins with a single quotation mark |"| continues until the next unescaped |"|.  The closing delimiter may be on another line, so long as the string (with delimiters included) contains no lines consisting solely of Unicode whitespace, all lines have the same indentation (except for the first line if the string does not start at the beginning of the line), and no line begins with Unicode whitespace after common indentation has been removed.  The string is unwrapped by stripping |\n| when preceded by Unicode whitespace and replacing |\n| with a space otherwise.  Indentation rules are described in \cref{sec:indentation}.
\item Two adjacent quotation marks |""| represent the empty string.
\item Three or more adjacent quotation marks |"""{1,n}| represent the beginning of a string in which any sequence of quotation marks |"| of a different length than the delimiters may appear literally, without escaping.\footnote{Requiring that the delimiters be longer than any internal sequence of quotation marks would have had the advantage that quoting a \bespon\ string including its delimiters would be as simple as adding longer delimiters.  However, this would also have the severe disadvantage of requiring extremely long delimiters for a string that contains a long sequence of quotation marks but no quotation marks otherwise.}  The string ends at the next sequence of quotation marks that is the same length as the opening sequence.  The treatment of newlines and leading whitespace depends on the ending delimiter.
    \begin{itemize}
    \item If the string ends with |"""{1,n}|, the string is treated just like the |"| case, with the exception that sequences of |"| of other lengths may appear literally.
    \item If the string ends with |"""{1,n}/|, the opening and closing delimiters must be on lines separate from the actual string content, and those lines do not contribute to the string content.  All newlines are preserved, and a newline character or characters besides |\n| may be specified via explicit typing (\cref{sec:advanced-options}).  All lines must be indented to at least the level of the closing delimiter, except for lines consisting solely of whitespace; all indentation in common with the closing delimiter is stripped.  The opening delimiter must be at the same indentation level as the closing delimiter unless it is not at the beginning of the line, in which case indentation rules apply (\cref{sec:indentation}).
    \item If the string ends with |"""{1,n}//|, the string is treated exactly like the |"""{1,n}/| case, except that the final newline is stripped.  More than two slashes |/| immediately after the quotation marks that end a multiline string must result in an error.
    \end{itemize}
\end{itemize}


\paragraph{Quoted literal strings}

Quoted literal strings are quoted with single quotation marks U+0027 (|'|).  There are no backslash escapes; all characters are treated literally.  The exact behavior of a quoted literal string depends on the quotation mark delimiters.
\begin{itemize}
\item A quoted literal string that begins with a single quotation mark |'| continues until the next |'|.  Indentation and line unwrapping are the same as for the |"| case.  Since escaping is not allowed, it is impossible for a single quotation mark |'| to be represented in such a string.
\item Two adjacent quotation marks |''| represent the empty string.
\item Three or more adjacent quotation marks |'''{1,n}| are treated in the same way as the |"""{1,n}| case, except that there are no escapes and except for the treatment of leading and trailing whitespace when the closing delimiter is |'''{1,n}| (no immediately following slashes |/|).  When the delimiters are |'''{1,n}|, a space at the beginning of the string is stripped if the first non-whitespace character is a single quotation mark |'|, and a space at the end of the string is stripped if the last non-whitespace character is a |'|.  This allows, for example, |''' ' '''| to represent the single quotation mark alone, with no leading or trailing whitespace.
\end{itemize}


\subsubsection{Byte string (\texttt{b})}

A byte string is an explicitly typed Unicode string consisting only of printable ASCII characters (U+0021--U+007E), spaces (U+0020), tabs (|\t|), newlines (|\n|), and escaped bytes that is converted to binary by encoding with ASCII.  Byte strings are distinguished from Unicode strings by the presence of an explicit type declaration, for example, |(b)> "\x00abc"|.

Byte strings may be unquoted or quoted, following the same rules as Unicode strings.  A quoted escaped byte string must only use backslash escapes of the form |\xHH|; |\u| and |\U| escapes are not allowed.


\subsubsection{Base16 (hexadecimal) (\texttt{b16})}

A base16 string is an explicitly typed Unicode string that matches the regular expression |[0-9a-fA-F]*| once whitespace is stripped.  It is treated as a hexadecimal encoding of a byte string.


\subsubsection{Base64 (\texttt{b64})}

A base64 string is an explicitly typed Unicode string that is decoded to a byte string with the Base64 algorithm in accordance with \href{https://tools.ietf.org/html/rfc3548}{RFC 3548}, using |+| and |/| as values 62 and 63, and using |=| as the padding character.  Because the equals sign |=| is a special character in \bespon, base64 data must always be quoted.  All whitespace is stripped from the quoted string before decoding begins; this allows base64 encoded data to be hard wrapped.


\subsection{Collection types}

Collection core types are core types that are collections of other objects.  Collection types may contain scalar objects and collection objects.  Collection elements must not be overwritten once created; an attempt to overwrite must result in an error.

An empty collection type is not allowed to be indicated solely by an explicit type declaration.  For example,
\begin{Verbatim}
(list)>
\end{Verbatim}
does not represent a valid empty list.  Instead,
\begin{Verbatim}
*
\end{Verbatim}
or
\begin{Verbatim}
[]
\end{Verbatim}
is required.  Similarly,
\begin{Verbatim}
(dict)>
\end{Verbatim}
does not represent a valid empty dict.  Instead,
\begin{Verbatim}
{}
\end{Verbatim}
is required.

\subsection{List (\texttt{list})}

A list is an ordered collection of objects.  Lists are heterogeneous; list elements may be of any type.

Lists are zero-indexed with integers.  List elements may also be accessed using negative integers, where |-1| is the last element in the list, |-2| is the second-to-last element, etc.  For additional information about using list indexing, see the discussion of keypaths (\cref{sec:keypath}).

In indentation-based form, each list element is denoted with an asterisk U+002A (|*|).  The |*| must be the first non-whitespace character on the line and must be indented relative to any parent object, and the list element content must be separated from the |*| by whitespace and be indented relative to it.  For example,
\begin{Verbatim}
* Unquoted string
\end{Verbatim}
If the indentation characters immediately adjoining the |*| on both sides are tabs |\t|, then the |*| is not counted toward the total effective indentation of the list element content, and the list element content must have a total effective indentation of one character more than the indentation of the |*|.  Otherwise, the |*| is treated as a space for the purpose of determining total effective indentation, and the list element content must have a total effective indentation of two characters more than the indentation of the |*|.  If the line immediately after the |*| is empty, and the list element only begins on a subsequent line, then the method of determining total effective indentation depends on whether a space (minimum two greater indentation) or tab (minimum one greater indentation) is in the column of the |*|.  Since the |*| determines the effective indentation of the list element content, it is the only non-whitespace character that is not counted when determining whether an object is at the beginning of a line.

Only a single |*| is allowed on a line.  A list of lists would require multiple |*| on multiple lines.  For example,
\begin{Verbatim}
*
  * A string in a list with a list inside.
\end{Verbatim}
This prevents situations such as
\begin{Verbatim}
* * * A string in a list in a list in a list
  * Another string in a list in a list
\end{Verbatim}
Such a case could add cognitive load.  It might also make indentation that mixes spaces and tabs ambiguous (although that should be avoided anyway).

In inline syntax, the beginning and end of a list are denoted by square brackets U+005B and U+005D (|[]|), and list elements are separated by commas U+002C (|,|).  For example,
\begin{Verbatim}
[1, 2, 3]
\end{Verbatim}
Trailing commas are allowed.


\subsection{Dictionary (\texttt{dict})}
\label{sec:type:dict}

A dictionary is an associative array that maps objects with scalar types to objects with arbitrary types.  Keys must be unique and duplicate keys are not allowed by default.

Dictionary keys must be scalar types by default, since these will have the best cross-language support.  When possible, it is recommended that only Unicode strings be used as keys.  Some languages perform type coercion on some non-string keys.  For example, Python treats |True|, |1|, and |1.0| as identical keys; |False|, |0|, and |0.0| are also treated as identical.  In addition, using floats as keys can be problematic due to rounding errors.

Additional restrictions are placed on unquoted strings that are used as dict keys, regardless of any built-in or custom typing applied to the strings.  These unquoted strings must not contain the period or full stop U+002E (|.|), since the period is reserved for keypaths (\cref{sec:keypath}).  Strings that contain a literal period must be quoted.  The only exception is that an implementation must allow periods in extended or user-defined numerical types, which must be explicitly typed (unless the implementation allows a regex to be specified to enable implicit typing, in which case it is allowing custom behavior beyond the \bespon\ spec).

An implementation may provide an option to enable collection types as keys, but this must not be the default.  If an implementation supports collection keys, its documentation must explain how mutable collection types are handled (for example, whether they are hashed by identity or by content).

In indentation-based form, a dict key must be at the beginning of a line.  The only exception is that a key may follow a |*| if the dict is in a list (since the |*| does not affect start-of-line state).  The key is separated from the value by an equals sign U+003D (|=|), which must be on the same line as the end of the key.  For example,
\begin{Verbatim}
key = value
\end{Verbatim}
The value must be indented relative to the key, except that a quoted string may have the same indentation as the key if the opening delimiter is on the same line as the end of the key.

In inline form, the beginning and end of a dict are denoted by curly braces U+007B and U+007D (|{}|), with key-value pairs separated by commas U+002C (|,|).  For example,
\begin{Verbatim}
{key1 = value1, key2 = value2}
\end{Verbatim}
Trailing commas are allowed.




\section{Extended types}

Core types must be supported unless a programming language lacks them.  Implementations are encouraged to support extended types, but this is not required.  By default, all extended types require the use of an explicit type declaration.  An implementation may provide an option to enable implicit typing of some extended types, but this must not be the default and must be considered a custom addition beyond the \bespon\ spec.  An implementation must raise an error when an unsupported extended type is used.


\subsection{Extended scalar types}

\subsubsection{Decimal (\texttt{decimal})}

Decimal floating point number, which represents decimal numbers exactly.  The |decimal| type must use the combined decimal parts of the |float| and |int| regexes.  Since the typing is explicit, there is no need to force a decimal point followed by a zero (|.0|) for integer-valued decimals; this is only necessary in the |float| case because implicit typing would otherwise make it impossible to distinguish integer-valued floats from ints.  As in the |int| and |float| cases, a value that would cause an overflow must result in an error.


\subsubsection{Rational (\texttt{rational})}

Rational number.  The |rational| type must use the |int| regex, followed by the solidus U+002F (|/|) surrounded by optional spaces and tabs, followed by the |int| regex.


\subsubsection{Complex (\texttt{complex})}

Complex number.  The |complex| type must use the combined decimal parts of the |float| and |int| regexes to identify valid numbers.  At least one of the real and imaginary parts must be present.  The imaginary part must use a number followed immediately by |i|.  Precision is not specified, but a 64-bit float is expected for both the real and the imaginary parts.  As in the |int| and |float| cases, a value that would cause an overflow must result in an error.


\subsubsection{Arbitrary precision integer (\texttt{bigint})}

This type must use at least the decimal part of the |int| regex.  Using the full |int| regex is encouraged when practical.


\subsubsection{Arbitrary precision float (\texttt{bigfloat})}

This type must use the combined decimal parts of the |float| and |int| regexes.  Using the full regexes is encouraged when practical.


\subsubsection{Date, time, and datetime (\texttt{date}, \texttt{time}, and \texttt{datetime})}

|date| is an \href{http://tools.ietf.org/html/rfc3339}{RFC 3339} |full-date|, without any timezone or offset specified.  |time| is an RFC 3339 |partial-time| with an optional |time-offset| (which, if present, makes it a |full-time|).  |datetime| is an RFC 3339 |date-time| in which the |time-offset| is optional.

All type instances that lack RFC 3339 |time-offset| do not in and of themselves contain enough information to be connected to a specific duration or instant in time.  Working with them correctly depends on users establishing a convention for their meaning and also being aware of any implementation-specific details that may affect their interpretation.  Implementations must deal with type instances that lack RFC 3339 |time-offset| in such a way that these instances can be distinguished from those that do have a |time-offset|.

An implementation that supports any of these types must include in its documentation any limitations or shortcomings of the objects to which these types are converted.  This includes potential issues related to leap years, daylight savings time, and leap seconds.

When creating time data, the full available fractional second precision should be used by default.  When loading time data, if the second precision exceeds the capacity of the available time implementation, the second data must be truncated rather than rounded.



\subsection{Extended collection types}

\subsubsection{Ordered dictionary (\texttt{odict})}

A dictionary in which key-value pairs are accessible in the order inserted.


\subsubsection{Set (\texttt{set})}

An unordered, unique collection of objects that allows membership testing.  This type is applied to a list.


\subsection{Array (\texttt{array})}

A list-like collection of homogenous types.  Typical usage would involve the definition of |array.<scalar>| for some or all of the core or extended scalar types.  For example, |array.int| would be an array of integers, while |array.complex| would be an array of complex numbers.  In this latter case, explicit type declarations may be omitted so long as all members of the array meet the appropriate pattern and thus may be converted to the appropriate type; members of a typed array may inherit their typing from the array rather than requiring explicit type declarations on a per-object basis.



\section{Comments}

Comments use the percent sign U+0025 (|%|).  There are three forms of comments, some of which closely follow the syntax for quoted strings.

Comments are not ignored in determining whether an object is at the beginning of a line.  When data is represented in indentation-based form, an inline comment at the beginning of a line is taken into account in determining the effective indentation of anything that follows it; comments are not simply stripped.

\paragraph{Line comments}

A single |%| starts a comment that continues until the end of the line.  Two |%%| in a row indicates the start of a line comment followed by a literal |%|, which is discarded as part of the comment.


\paragraph{Inline comments}

An inline comment starts with at least three percent signs, |%%%{1,n}| and continues until the same number is encountered.  It follows the same rules as the corresponding quoted strings.  An inline comment cannot contain any lines consisting solely of whitespace.  It may begin and end on the same line.

If the opening delimiter of an inline comment is at the beginning of a line, then the entire comment must use the indentation of the opening delimiter.  Otherwise, the indentation of all lines of the comment except for the first line must be identical and follow the indentation rules for quoted strings (\cref{sec:indentation}).


\paragraph{Multiline comments}

A multiline comment begins with |%%%{1,n}| and continues until |%%%{1,n}/| is found.  It may contain anything except for a sequence of |%| of the same length as the delimiters.  The opening delimiter must only be followed by whitespace on its line, and the closing delimiter must only be preceded by whitespace on its line.  The closing delimiter must not be followed immediately by a slash |/|.

If the opening delimiter of a multiline comment is at the beginning of a line, then all lines in the comment must have at least the indentation of the opening delimiter or be completely whitespace, and the closing delimiter must have the same indentation as the opening delimiter.  Otherwise, the minimum indentation level for the comment is inherited from the line on which it starts, and all lines must either consist of whitespace or be indented by at least as much as the ending delimiter. This follows the indentation rules for quoted strings (\cref{sec:indentation}).




\section{Indentation}
\label{sec:indentation}

\bespon\ has an indentation-based form and an inline form.  Indentation rules are different for the two cases.

A dataset always starts in indentation-based form.  It transitions to inline form within an explicit type declaration (|(...)>|), within an inline list (|[...]|), and within an inline dict (|{...}|).

By default, both spaces U+0020 and tabs U+0009 are allowed as indentation.  These are always treated as distinct characters; there is never any conversion of tabs into some equivalent number of spaces.  This means that while it is technically legal to mix spaces and tabs, doing so requires that the exact same sequence of spaces and tabs always be used to obtain a given indentation level.


\subsection{Indentation-based form}

In indentation-based form, indentation is used to indicate the hierarchy of the dataset.  An object that is part of another (collection) object is indented relative to indentation level of the parent object.

An explicit type declaration and its object may be at the same indentation level.
\begin{Verbatim}[commandchars=\\\{\}]
\darrow{}(str)>
\darrow{}"A string"
\end{Verbatim}
If the object is indented relative to the explicit type declaration, then the effective indentation is the indentation of the object.  The effective indentation is used for all sub-objects
\begin{Verbatim}[commandchars=\\\{\}]
\darrow{}(str)>
\darrow{} \darrow{}key = 
\darrow{} \darrow{} value
\end{Verbatim}

A string that starts at the beginning of a line (only preceded by indentation or |*|) must use the same indentation for all subsequent lines, unless it is a multiline string (indentation and newlines preserved), in which case subsequent lines may be entirely whitespace or may have more indentation.  Note that a single |*| that begins a list element does not change beginning-of-line status.  Anything else besides whitespace does change beginning-of-line status, including comments. 
\begin{Verbatim}[commandchars=\\\{\}]
*\darrow{}An unquoted
 \darrow{}multiline string
*\darrow{}"""A quoted
 \darrow{}multiline string"""
*\darrow{}'''
 \darrow{}  Another quoted multiline string
 \darrow{}  with preserved newlines and indentation
 \darrow{}'''/
\end{Verbatim}

An unquoted string that does not start at the beginning of a line must use an indentation level that is at least one greater than the line on which it starts, because otherwise the string continuation could not be distinguished from a new object (since there are no delimiters).  A quoted string that does not start at the beginning of a line may use the indentation level of the line on which it starts.
\begin{Verbatim}[commandchars=\\\{\}]
\darrow{}key1 = An unquoted
\darrow{} multiline string
\darrow{}key2 = """A quoted
\darrow{}multiline string"""
\darrow{}key3='''
\darrow{}  Another quoted multiline string
\darrow{}  with preserved newlines and indentation
\darrow{}'''/
\end{Verbatim}

Inline and multiline comments follow the same indentation rules as quoted strings, except that when the opening comment delimiter is at the beginning of a line, it may be at any indentation level.

\subsection{Inline form}

Inline form begins with the start of an explicit type declaration |(|, list |[|, or dict |{|.  If the beginning of inline form is also at the beginning of a line, then the indentation of the |(|/|[|/|{| sets the indentation for inline form.  Otherwise, the indentation is inherited from the object preceding the start of inline form.  Within inline form, any indentation is allowed, as long as it is greater than or equal to the indentation that was in place when inline form began.  It is the responsibility of the user to format data in a readable manner.
\begin{Verbatim}[commandchars=\\\{\}]
\darrow{}\{  (str)>
\darrow{}  key = 
\darrow{} value
\darrow{}   \}
\end{Verbatim}

In inline form, the rules for relative indentation within a string must still be followed; there is just more flexibility regarding the overall indentation.  An unquoted string is not required to have more indentation than the inline indentation, since it must be separated from other objects by a comma if nothing else.  Quoted strings likewise are only required to use the inline indentation.  In both cases, the rules for relative indentation within a string are still in effect.
\begin{Verbatim}[commandchars=\\\{\}]
\darrow{}\{ key1 = An unquoted
\darrow{}multiline string,
\darrow{}    key2 = """A quoted
\darrow{}multiline string""",
\darrow{}      key3='''
\darrow{}  Another quoted multiline string
\darrow{}  with preserved newlines and indentation
\darrow{}'''/\}
\end{Verbatim}




\section{Keypaths}
\label{sec:keypath}

\bespon\ provides a compact keypath notation for working with deeply nested objects.  In dict keys, the period U+002E (|.|) is a special character that separates path elements; it is not allowed to appear literally except in numbers or quoted strings.  Thus,
\begin{Verbatim}
key.subkey = value
\end{Verbatim}
is equivalent to
\begin{Verbatim}
key = {subkey = value}
\end{Verbatim}
The elements in a keypath must be valid unquoted strings and must not contain Unicode whitespace, unless escaping is performed as described below.  Indentation characters are allowed before and after periods, but this is discouraged.  An entire keypath must fit on a single line; line breaks are not allowed within keypaths.

This notation is convenient for working with alphanumeric keys that begin with an alphabetic character or otherwise do not fit the pattern for a number, but what of lists, numerical keys, and keys that are reserved words or include special characters?

\paragraph{Lists}

List elements are accessed in one of two ways.  Using |*| adds a new list element, while using |[|\vmeta{decimal integer}|]| allows pre-existing list elements to be accessed by index.  For example,
\begin{Verbatim}
key.* = value
\end{Verbatim}
is equivalent to
\begin{Verbatim}
key.[0] = value
\end{Verbatim}
which is equivalent to
\begin{Verbatim}
key = [value]
\end{Verbatim}
Indentation characters are allowed before and after \vmeta{decimal integer}, but this is discouraged.


\paragraph{Numerical keys}

Numerical keys are used by wrapping them in curly braces |{}|.  For example,
\begin{Verbatim}
key.{123} = value
\end{Verbatim}
is equivalent to 
\begin{Verbatim}
key = {123 = value}
\end{Verbatim}
Indentation characters are allowed after the opening brace and before the closing brace, but this is discouraged.

\paragraph{Reserved words, special characters, and explicit typing}

Reserved words and special characters may be used in keypaths by quoting them and then wrapping them in curly braces.  For example,
\begin{Verbatim}
key.{'true'} = value
\end{Verbatim}
is equivalent to 
\begin{Verbatim}
key = {'true' = value}
\end{Verbatim}
Multi-delimiter quoting is allowed, but a keypath must never wrap onto a second line and thus cannot contain a multiline string with literal indentation or newlines.

Explicit typing is allowed.  For example,
\begin{Verbatim}
key.{(b)> abc} = value
\end{Verbatim}
is equivalent to
\begin{Verbatim}
key = {(b)> abc = value}
\end{Verbatim}


\paragraph{Special keypath characters}

The underscore U+005F (|_|) is special when it is the first element in a keypath, and must not otherwise appear by itself in a keypath without quoting (as |{_}| or |{'_'}|, etc.).  It refers to one level up from the last location.  For example,
\begin{Verbatim}
key.subkey.* = value1
_.* = value2
\end{Verbatim}
is equivalent to
\begin{Verbatim}
key  = {subkey = [value1, value2]}
\end{Verbatim}

The solidus (slash) U+002F (|/|) is not allowed by itself unquoted in a normal keypath (|{/}|, |{'/'}|, etc.).  It is used in keypath aliases to denote the root data level.  In these situations, it is only allowed as the first element in a keypath.

The caret U+005E (|^|) is not allowed by itself unquoted in a normal keypath.  It is used in keypath aliases to refer to higher relative levels in the data structure.  It is only allowed as the first element in a keypath (|^.key|, |^^.key|, etc.).  Each additional |^| in a sequence indicates going up in the data structure by another level.

\section{Sections}

In indentation-based form a section may be declared, which sets the relative location for all data that follows it.  Sections consist of three or more equals signs at the beginning of a line, followed by optional spaces, followed by a keypath.  For example,
\begin{Verbatim}
=== key.subkey
* value1
* value2
\end{Verbatim}
is equivalent to
\begin{Verbatim}
{key  = {subkey = [value1, value2]} }
\end{Verbatim}
The contents of a section may have the same indentation level as the section.

Sections are only allowed at root level.  The opening equals sign |=| must have indentation consistent with any preceding data that sets the root-level indentation.

A section ends at the next section.  Returning to root level is possible by using |==={1,n}/|.  Because of the special use of the slash here and in keypaths used as path aliases, a literal unquoted slash is not allowed in a keypath.



\section{Advanced options and types}
\label{sec:advanced-options}

Implementations are encouraged to include advanced types and options, but this is not required due to the added complexity.  When an unsupported advanced option or type is encountered, an error must be raised.

\subsection{Advanced options}

The explicit type declaration syntax may also be used for specifying advanced options:
\begin{Verbatim}[commandchars=\\\{\}]
(\meta{type}, \meta{key-value options})>
\end{Verbatim}
All option keys must be unquoted strings meeting the regex |[a-zA-Z][a-zA-Z0-9_-]*|.  Values must be boolean or Unicode strings (quoted or unquoted, but no block strings).  When an option is given that is incompatible with a type, an error must be raised.  The \vmeta{type} may be omitted for implicitly typed objects.


\subsubsection{General options}

\paragraph{label}
This gives an object a label, which can later be used to reference the object in a label alias.  Labels must be Unicode strings.  Unquoted ASCII strings meeting an identifier style regex |[a-zA-Z][a-zA-Z0-9_-]*| should be preferred.


\subsubsection{Options for string-like objects}

\paragraph{newline}
This specifies a character or sequence of characters that will be used to replace all literal newlines (|\n|) in a string.  Only Unicode newline code points and sequences from the Unicode Newline Guidelines (\href{http://unicode.org/standard/reports/tr13/tr13-5.html}{Unicode Technical Report \#13}) are allowed.  The newline replacement must be given as a quoted, escaped string containing only the escaped representation of the code point(s).  This option only applies to block strings (Unicode strings, byte strings, or custom types applied to Unicode strings).


\subsubsection{Mutually exclusive options}

\paragraph{init}

This provides initialization for collection types, using one or more existing collection objects.  It is only valid for collection types.  It comes in two variants. |init.path| takes a keypath or an inline list of keypaths.  |init.label| takes a label or an inline list of labels.  All init objects for a collection with type \vmeta{type} must have the same type as \vmeta{type}, or be untyped with a default type that is compatible with \vmeta{type}.  For a dict-like object, |init| must only contain dict-like objects, and similarly for list-like objects.  For a dict-like object, |init| adds all of the keys in the init objects to the dict-like object, with the keys referring to their original values.  This is effectively a ``shallow merge'' in which duplicate keys are not allowed.  For a list-like object, |init| adds all of the elements in the init objects to the list-like object, \emph{before} the object's own elements are added.  This is effectively initialization by list extension, with the objects in the init list undergoing shallow list flattening.  In both cases, the init objects are not copied; only new aliases to their contents are created.

When a list-like collection object uses |init|, if a keypath is used to add elements by index, the index of the final collection, post-initialization, must be used.  For this reason, adding elements by keypath index is discouraged, and keypaths of the form \vmeta{path}|.*| should be preferred.  Using an index means that data depends on the specific number of elements provided by |init|.


\paragraph{deepinit}

This is the deep copy version of |init|.  The resulting object contains deep copies of the contents of all |init| objects.


\paragraph{default}

This allows default values to be specified for a collection type.  It comes in two variants. |default.path| takes a keypath or an inline list of keypaths.  |default.label| takes a label or an inline list of labels.  All default objects must have the same type as \vmeta{type}, or be untyped with a compatible default type.  After a collection with |default| is fully assembled, the default objects are checked to insert missing key-value pairs (dict-like) or elements (list-like).  For a dict-like object, the list of keypaths or labels is traversed in order, and all missing keys are inserted.  Existing key-value pairs are not overwritten, since |default| provides only \emph{default} fallback values, and \bespon\ does \emph{not} allow overwriting.  The treatment of dict-like objects is effectively a ``shallow merge.''  For a list-like object, the list of keypaths or labels is traversed in order, and all elements in the default objects are appended.  This is effectively a list extension, or shallow list flattening.  For a list-like object, |init| and |default| provide identical results, except that elements from the init/default objects are inserted first in |init| and last in |default|; elements are not combined by index.


\paragraph{deepdefault}

This is the deep copy version of |default|.  The resulting object contains deep copies of the contents of all |default| objects.


\paragraph{recmerge}

This performs a recursive merge.  It comes in two variants. |recmerge.path| takes a keypath or an inline list of keypaths.  |recmerge.label| takes a label or an inline list of labels.  Starting with the original collection object, a recursive merge is performed at all levels (only collection objects are merged).  A dict-like object can only be merged into another dict-like object, and only if the first dict-like object is untyped (implicit, default type) or has the same type as the object it is being merged into.  Merging is performed by inserting missing key-value pairs; existing keys are never overwritten, but if their values are collection types, then merging is performed recursively.  A list-like object can only be be merged into another list-like object, and only if the first list-like object is untyped (implicit, default type) or has the same type as the object it is being merged into.  List merging is performed as list extension; lists are not combined by index.

All collections that are merged appear in the final data structure alone.  All collections that are not merged are aliased.


\paragraph{deeprecmerge}

This is the deep copy version of |recmerge|.  The resulting object contains deepcopies of all merged collections, regardless of whether a given collection was merged.



\subsection{Advanced types}
Advanced types are applied to keypaths and create aliases or copies of the object referred to by a keypath.  Keypaths are always taken as relative to the current location, unless the first element is a slash |/|, which references the root of the dataset, or one or more carats |^|, which indicate a number of levels to move upward in the dataset before traversing the remainder of the keypath from that level.

Shallow copies of collection types must produce new collection objects containing aliases of the members of the original collection.  Shallow copies of scalar types may produce new scalar objects or alias the original object, in an implementation- and language-specific manner.  Whether scalar types are immutable as far as copying is concerned is left up to the implementation and the programming language.  The behavior of copies must be documented by an implementation.

\paragraph{alias.path}
This creates an alias to the object referred to by a keypath.

\paragraph{alias.label}
This creates an alias to the object referred to by a label.

\paragraph{copy.path}
This creates a shallow copy of the object referred to by a keypath.

\paragraph{deepcopy.path}
This creates a deep copy of the object referred to by a keypath.

\paragraph{copy.label}
This creates a shallow copy of the object referred to by a label.

\paragraph{deepcopy.label}
This creates a deep copy of the object referred to by a label.




\subsection{Resolving aliases, copies, and dependent collections}

Aliases are only resolved once the aliased object is resolved, with the exception that circular aliases may be resolved in ``simultaneously'' with their targets.  If this is impossible, then an implementation must raise an error.  For example, suppose that an implementation adds support for an immutable |tuple| collection type, as exists in Python.  Then this could not be resolved:
\begin{Verbatim}
(tuple, label=t)> [1, 2, 3, (alias.label)> t]
\end{Verbatim}
The tuple must exist before the 4th element in it can alias the tuple, but once the tuple exists it cannot be modified to contain an alias to itself.  In contrast, this case would be possible with a mutable |list|, as exists in Python:
\begin{Verbatim}
(list, label=t)> [1, 2, 3, (alias.label)> t]
\end{Verbatim}
In this case, the list would be created with a \bespon\ alias object as its last element, and then the alias could be resolved since it is in a mutable data structure.  In a mutable collection object that may only contain specified types, a placeholder object could be inserted until the alias is resolved.  Mutability is key for resolving these sorts of circular aliases.

Copies are only performed on objects after they have been fully resolved.  This means that when a copy of a collection object containing an alias is made, the alias must have already been resolved.  Thus, a deep copy will copy everything, including everything that is aliased; it will result in a deep copy of the aliased object, rather than a copy of the alias itself.  It is prohibited to create a copy of an object that itself contains an alias of the copy that is to be created.

A dependent collection is any collection with |init|, |default|, |recmerge|, or the deep copy equivalents.  A dependent collection is only resolved once all of the dependencies are resolved.  Thus, collections in |init|, |default|, or |recmerge| are prohibited from containing aliases to the dependent collection.




\section{Parser directives}
\label{sec:parser-directive}

Parser directives allow a dataset to require parsing according to a different set of rules than the defaults.  When a parser is initialized, a number of parsing settings are given initial (typically default) settings.  Parser directives allow these settings to be modified.  Directives may restrict settings from their initial values to use a more strict approach.  Directives may also request broader settings than the defaults, in which case an error must be raised if the requested settings exceed those allowed by the parser.

An entire dataset may be ``typed'' by a parser directive of the form
\begin{Verbatim}[commandchars=\\\{\}]
(bespon, \meta{key-value options})>
\end{Verbatim}
Only a single parser directive is allowed in a dataset, and it must appear before any data and before any comments; it may only be preceeded by whitespace.  This ensures that it is at the beginning of a dataset, where it may be easily inspected.  Because of the existence of parser directives and special \bespon\ types, implementations that allow user-defined types must prohibit custom types with names starting with the literal string |bespon|.

An implementation is not required to implement parser directives, but any implementation that does not must note this in its documentation and must raise an informative error when a parser directive is encountered.  

\paragraph{unquoted\_strings}
This boolean option determines whether any unquoted strings (typed or untyped) are allowed.  True by default.  When this option is false, unquoted reserved words and unquoted implicitly typed objects (|none|, booleans, numbers, etc.) are still allowed.  Type names and type options are still used unquoted.  All of these are matched by regex or other means, and there is no danger of ambiguity.  Only text that would have otherwise become Unicode string data before any explicit typing must be quoted.

\paragraph{unquoted\_unicode}
This boolean option determines whether code points beyond the ASCII range may appear unquoted.  False by default.  Note that enabling unquoted Unicode has security implications, since the full Unicode range contains many characters that closely resemble ASCII characters or are invisible or nearly invisible, potentially in a font- and editor-dependent manner.  Unquoted strings are restricted to the ASCII range by default because of the incredible complexity of attempting to allow unquoted Unicode while completely avoiding \href{http://unicode.org/reports/tr36/}{visual spoofing and associated security issues}.

\paragraph{only\_ascii}  Only allows unescaped characters in the ASCII range.  False by default.  May be useful when Unicode security is a significant concern.

\paragraph{ints}  Allow integers.  True by default.  If false, all strings that match the integer regex are treated as floats.

An implementation must use the default values for all directive settings unless other values are specified by the user.  A parser directive can never turn |unquoted_strings| or |unquoted_unicode| or |ints| on when the implementation has it off, or turn |only_ascii| off when the implementation has it on.  A parser directive must only restrict parsing relative to what the implementation allows with current settings; a parser directive must never cause less strict parsing than what the implementation allows with its initial settings.  Doing so could have security implications.  Any parser directive that conflicts with current implementation settings must result in an error, which should explain how the error may be resolved and mention potential security implications.  Any acceptable parsing directive affects the parsing of the data set in which it occurs, but the parser must reset settings to their original values before parsing any additional datasets.

A \bespon\ dataset that uses |unquoted_strings|, |unquoted_unicode|, |only_ascii|, or |ints| is not required to have a parser directive.  All parties working with a given dataset may agree to non-default parser settings and thus omit the explicit parser directive.  However, this is discouraged, since such a file will result in an error when loaded by a default implementation if a more permissive setting is required (|unquoted_unicode|), and could result in unintended behavior otherwise (|unquoted_strings|, |only_ascii|, |ints|).


\section{Implementation considerations}

An implementation must provide a programmatic way to determine which types have built-in support, and whether they are mutable.

An implementation should provide means of adding additional, user-defined types for use with explicit typing.  A dict mapping type names to parsing functions may be a convenient way to define additional types.  By default, all type names must match the regex
\begin{Verbatim}
[a-zA-Z](?:[0-9a-zA-Z]|[_-](?=[0-9a-zA-Z]))*
   (?:\:\: [a-zA-Z](?:[0-9a-zA-Z]|[_-](?=[0-9a-zA-Z]))* | 
      \.[a-zA-Z](?:[0-9a-zA-Z]|[_-](?=[0-9a-zA-Z]))*
   )*$
\end{Verbatim}
Type names are never quoted, so they must match an identifier-style regex to avoid any potential ambiguity with implicitly typed objects.  In addition to matching the regex, type names must not match regexes and associated patterns for all types that are implicitly typed, including reserved words.  Libaries are encouraged to use type names of the form \vmeta{lib\_name}|::|\vmeta{type} for library-specific types that are not defined in the \bespon\ specification and whose interpretation is not immediately obvious.  

An implementation should provide an option for registering a post-processing function for Unicode strings.  This would receive Unicode strings before they are stored in final form, and would make it convenient to add additional implicitly typed objects for custom usage.









%
%
%\section{File format}
%
%The default encoding for \bespon\ files is UTF-8.  The use of a UTF-8 byte order mark (BOM) is strongly discouraged, but it should be checked for and discarded.
%
%\bespon\ libraries that work directly with files are encouraged to support an encoding option for use with legacy applications or in situations in which UTF-16 or UTF-32 are desirable.  If such a library supports UTF-16 or UTF-32, it should correctly handle BOMs.  A library that only works with decoded text should attempt to check for BOMs for these formats as well.  When an encoding other than UTF-8 is used, it is the responsibility of the sender and receiver to agree on an encoding and act appropriately.  Regardless of the encoding used for a \bespon\ file, the decoded text cannot contain unpaired UTF-16 surrogates (0xD800--0xDFFF).
%
%By default, some code points may not appear literally in a \bespon\ file.  They may only appear within escaped strings, which use |\xHH| (8-bit), |\uHHHH| (16-bit), and |\UHHHHHHHH| (32-bit) hex notation, as well as the shorthand sequences |\\|, |\'|, |\"|, |\a|, |\b|, |\e|, |\f|, |\n|, |\r|, |\t|, |\v|.\footnote{Note that some of the shorthand sequences represent characters that are allowed to appear literally.  These escaped forms are only used in escaped strings.  Which quotation mark escaping is necessary depends on the string delimiters.  The escape |\/| should be allowed for cases when similarity to JSON is desired.  A library should recognize all of the short escaped forms in reading, but may optionally use |\x|, |\u|, or |\U| forms instead in text it emits.}
%
%All characters with Unicode category ``Other, Control'' (Cc)\footnote{``Other, Control'' includes the range U+0000 to U+001F (ord 0--31), the character U+007F (ord 127, ``DELETE''), and U+0080 to U+009F (ord 128--159).} must not appear literally by default and must result in an error, with the following exceptions.  These characters must always be allowed as literals:
%\begin{itemize}
%\item Line feed U+000A |\n|
%\item Carriage return U+000D |\r|
%\item Horizontal tab U+0009 |\t|
%\end{itemize}
%For the purposes of line termination, |\n|, |\r|, and |\r\n| should be treated as identical.  Implementations may save \bespon\ files with |\r\n| in a system-dependent manner, but using |\n| is preferred.
%
%Two code points in the Unicode Bidi\_Control formatting characters must not appear as literals:  left-to-right override (U+202D) and right-to-left override (U+202E).   Bidi override characters can be a security concern in general, and are particularly problematic in a data serialization format designed for manual editing.  \href{http://unicode.org/reports/tr36/}{Unicode Technical Report \#36}, ``Unicode Security Considerations,'' recommends that overrides never be allowed in IRIs.
%
%There are five characters that may optionally be allowed as literals.  If these are allowed as literals, they must receive special treatment; if they are not allowed, they must produce errors if they appear.  None of these are currently required, because the first three are primarily useful in legacy applications (and are part of the Unicode Cc category), while the last two are relatively recent and not in common use.
%\begin{itemize}
%\item Form feed U+000C |\f|
%\item Vertical tab U+000B |\v|
%\item Next line U+0085 (NEL)
%\item Line Separator U+2028
%\item Paragraph Separator U+2029
%\end{itemize}
%If an implementation allows these as literals, they must be treated as line terminators for the purposes of parsing, in accordance with the Unicode Newline Guidelines (\href{http://unicode.org/standard/reports/tr13/tr13-5.html}{Unicode Technical Report \#13}).  They should also be preserved within strings, rather than replaced with |\n|, so that round-tripping is possible.
%
%A \bespon\ library may have an option that allows some or all of the disallowed characters to appear as literals.  However, this must not be the default.  When using such an option, special care should be taken to avoid security risks.  Control characters and override characters might be easily overlooked when they are allowed in unescaped form.  A \bespon\ library must provide an interface for determining the characters that are disallowed, particularly since some characters (the newlines) may optionally be allowed as literals.
%
%The sequence |%!bespon| may be used at the beginning of the first line of a \bespon\ file to indicate the format.  In the future, optional arguments that customize parsing or other features may be allowed on the first line, following the |%!bespon| sequence.  If the sequence |%!bespon| is detected on the first line of a file, and if it is followed by anything other than whitespace characters, an error must be raised unless (1) the \bespon\ spec has been expanded to include parser directives, (2) the parser supports directives, and (3) the content following the opening sequence can be parsed.  The sequence |%!bespon| may appear multiple times within a \bespon\ file that contains multiple datasets, as a delimiter between them.  That is, concatenated \bespon\ files are valid.  The sequence |%!bespon.eof| indicates the end of a file as far as \bespon\ is concerned; all content after it is discarded.  It may useful in cases in which an end-of-file delimiter is desirable (for example, parsing a log file that may still be open for writing).  It also effectively comments out the remainder of a file.  The sequences |%!besponb|, |%!bespon.bin|, and |%!bespon.binary| are reserved for possible future use in a binary-only variant of \bespon.  All of the |%!bespon| sequences should be recognized both in ASCII and in corresponding fullwidth forms (characters in U+FF01--U+FF5E).
%
%Due to the way that \bespon\ escapes strings, the empty string (|""| in many languages) will often only appear implicitly.  In compact syntax within a collection type, it appears as |;| (nothing---emptiness---before the collection element separator).  In non-compact syntax, it may be completely implicit.  A \bespon\ file that represents solely the empty string must at a minimum contain one or more whitespace characters, preferably newlines, after the removal of any BOM.  This prevents a genuinely empty file (for example, one created by |touch| under Linux) from being treated as a valid file.  A file that contains no characters after the removal of a BOM must result in an error.  A file containing only the empty string should use |%!bespon| on the first line, or explicit typing |(str.empty)>| followed by an implicit empty string, to improve clarity for manual editing.  In general, a \bespon\ file should always end with one or more newline characters.
%
%\section{Special characters}
%
%
%\bespon\ uses some characters for special purposes.  The set of special characters has been kept small, so that there is as little as possible to remember when escaping.  In many situations, a string must only be escaped if it begins with parentheses |()|, curly braces |{}|, square brackets |[]|, or quotation marks |'"|, or if it contains the percent symbol |%| or semicolon |;|.
%
%In special contexts, the equals sign |=|, slash (solidus) |/|, space and tab, plus sign |+|, greater-than sign |>|, period |.|, and underscore |_| also have meaning, but in such a way that extra escaping is typically not required.
%
%\bespon\ allows data to be represented in three forms:  a compact form, somewhat analogous to JSON; an indentation-based form, somewhat analogous to YAML; and an INI-style form, somewhat analogous to TOML.  Some characters only have special significance in some of these contexts.
%
%All special characters are in the ASCII range or in the fullwidth equivalents  U+FF01--U+FF5E, plus U+3000.  All special characters in the printable ASCII range except for the space (U+0021--U+007E) must be treated as identical to their fullwidth equivalents in U+FF01--U+FF5E.  For example, a list opened by the ASCII left square bracket |[| (U+005B) should be closed by the ASCII right square bracket |]| (U+005D), but could be closed by the fullwidth right square bracket \begin{CJK*}{UTF8}{gkai}|］|\end{CJK*} (U+FF3D).  Fullwidth ASCII equivalents are allowed to make the indentation-sensitive syntax more compatible with CJK characters.  They should not be used in non-CJK contexts.  The fullwidth characters in U+FF01--U+FF5E are treated as identical to their ASCII equivalents because distinguishing them could result in subtle errors when an ASCII character and its fullwidth equivalent are swapped.  For example, the list might appear to be closed by \begin{CJK*}{UTF8}{gkai}|］|\end{CJK*} (U+FF3D), but would not actually be.  This could have security implications.
%
%There is only one exception to treating ASCII characters as completely equivalent to their fullwidth counterparts.  A library may raise an error when paired special characters or groups of special characters, within a single pairing, are not all ASCII or not all fullwidth.
%
%The ASCII space U+0020 and ideographic space U+3000 have exactly the \emph{same role} as indentation characters in the indentation-sensitive syntax, but are never treated as \emph{identical} or as \emph{translatable} since there is not a universal ratio of their widths across all fonts.  In an ideal fixed-width font, the ratio of the width of the ideographic space to the space might be 2:1, but in practice, it is often more like 5:3.  Thus, any attempt to translate between the two would run into the same sorts of issues as attempts to treat horizontal tabs as equivalent to some number of spaces.
%
%
%\subsection{Comments -- percent sign and fullwidth percent sign (and trailing slash and trailing fullwidth solidus)}
%
%Single-line comments begin with the percent character |%| (U+0025) and continue to the end of the line.  A space between the |%| and the beginning of the comment is encouraged.
%
%Multiline comments begin with three or more percent characters, and continue until an identical group of percent characters is found.  The closing group of percent characters must be followed immediately by a slash |/| (U+002F).  This allows the beginning and end of a long comment to be easily distinguished, even in the absence of syntax highlighting.  In multiline comments, the delimiters should be on lines by themselves.  This makes multiline comments more quickly distinguishable from single-line comments.  The opening delimiter sequence is allowed to appear within the comment, but using it within comments, except to open the comment, is discouraged.
%
%Example of comments:
%\begin{Verbatim}
%% Single-line comment
%
%%%% 
%Multiline comment
%that goes on for two lines
%%%%/
%\end{Verbatim}
%
%The opening and closing delimiters of a multi-line comment may be on the same line, although this is discouraged except in inline contexts with compact notation.  When the end of a multi-line comment is removed from a line, parsing continues with the remainder of the line.  Because of the presence of the multi-line comment, the parsing position will not be considered to be at the beginning of the line.  In non-compact syntax, this will generally mean that the end of a multi-line comment should not be followed immediately by data.  While this would be possible, and could be worked out in a logical fashion, it would mean that indentation-sensitive syntax would be based not on actual visual indentation, but rather on logical indentation after comments are removed.  While this would not necessarily add complexity to parsing, it would add complexity to user interpretation.
%
%It would be possible to eliminate most of the need to escape the percent sign |%| by only having it start a single-line comment when it is the first non-whitespace character on a line, or when it is preceded by whitespace, but this approach is not used.  YAML requires that its comment character |#| be preceded by a space when it is not the first non-whitespace character; otherwise, it is literal.  This could be problematic in several respects.  If a comment character is preceded by a non-breaking space (U+00A0) or other Unicode whitespace character, it could appear that a comment has begun when in fact it has not.  While it would be possible to disallow non-space Unicode whitespace when before a comment character, that has already significantly increased the complexity of the syntax.  It has also not addressed the potential for confusion with other Unicode characters, such as the Hangul fillers (which often appear as spaces) and characters with a very minimal visual appearance.\footnote{For an example of characters with a minimal visual appearance, see \url{http://kb.mozillazine.org/Network.IDN.blacklist_chars}, for example, U+0704.}  Using such a parsing rule could avoid escapes, but only at the expense of additional complexity, mental overhead, and potential security risks.
%
%A comment may not interrupt another element.  A comment must not appear within an unquoted string or unquoted literal.  It may only appear before or after one.  A comment after an unquoted string or literal does not alter any requirements for a separating character or other syntax that indicates the end of the element or the separation of the element from subsequent elements.
%
%The fullwidth percent sign \begin{CJK*}{UTF8}{gkai}|％|\end{CJK*} (U+FF05) and fullwidth solidus \begin{CJK*}{UTF8}{gkai}|／|\end{CJK*} (U+FF0F) may be used instead of the percent sign and slash when working with CJK characters.  Otherwise, their use is discouraged.
%
%The sequence |%!bespon| is special.  It may be used at the beginning of the first line of a \bespon\ file to indicate the format.  Currently, this sequence must not be followed by anything but whitespace.  In future versions of the \bespon\, this sequence may optionally be followed by arguments that customize parsing or other features.
%
%The same sequence |%!bespon| may appear multiple times within a file as a delimiter between separate datasets.  That is, concatenated \bespon\ files are valid.  \bespon\ libraries should provide one mode for parsing \bespon\ files that contain only a single dataset.  This mode must raise an error if the sequence |%!bespon| is encountered anywhere other than the first line, with the exception that |%!bespon.eof| must always be valid as an end-of-file indicator.  Libraries should provide another mode that is used to parse files that contain multiple datasets.  This should make all datasets accessible via a list or array, or alternatively iterate over individual datasets.  This mode may also return a dict mapping dataset names to datasets, in the event that all datasets include metadata that gives each set a name.
%
%
%
%
%\subsection{Indentation -- space, tab, and ideographic space}
%
%Outside of multiline strings, indentation is only significant in the indentation-based and INI-style forms; in the compact syntax, it is ignored.
%
%Indentation is defined as the space (U+0020), horizontal tab (U+0009), and ideographic space (U+3000).  The space is the preferred form of indentation.  Four spaces per indentation level is encouraged.  Use of the tab is discouraged, but it is allowed for convenience.  The ideographic space may be used when working with CJK characters to provide better visual alignment of characters.  Otherwise, its use is discouraged.
%
%In determining indentation level, the space, tab, and ideographic space are always treated as distinct characters.  Tabs and ideographic spaces are never treated as equivalent to some number of spaces.  When a line of text is indented, its indentation characters must exactly match those of the previous line of text, except for those that give the line a greater indentation than the previous line.  Any indentation mismatch must result in an error.
%
%In some cases, indentation is based off of a mix of indentation characters and other characters.  For example, the first line of a list item might be indented with spaces and a plus sign:
%\begin{Verbatim}[showspaces]
% + List item
%   continues on
%\end{Verbatim}
%If the plus sign is preceded or followed by a space or ideographic space, it is counted as a character (equivalent to a space or ideographic space) for indentation purposes.  If ideographic spaces are used for indentation, then the fullwidth plus sign \begin{CJK*}{UTF8}{gkai}|＋|\end{CJK*} (U+FF0B) should be used instead of the plus sign (U+002B) to ensure correct visual alignment.  If the plus (or fullwidth plus) is both preceded and followed by a tab, then it is ignored in determining indentation level.  This approach is applied to all cases in which indentation level must be determined from a mix of indentation characters and a single other character.
%
%There is never an indentation level that mixes indentation characters with more than one non-indentation character.  If such a case were allowed, then it would be necessary to normalize Unicode characters and/or use their character categories to determine which code points should be treated as contributing to the indentation level.  For a data serialization library, it is simpler avoid this complexity.
%
%
%\subsection{Indented lists -- plus sign and fullwidth plus sign}
%
%In non-compact syntax, the plus sign |+| (U+002B) and fullwidth plus sign \begin{CJK*}{UTF8}{gkai}|＋|\end{CJK*} (U+FF0B) are used, together with indentation, to denote the beginning of list items.  The fullwidth plus should only be used when ideographic spaces are used for indentation, which should only be done with CJK characters.
%
%A plus (or fullwidth plus) only starts a list when it is the first non-indentation character on a line, is indented relative to the current indentation level, is followed by one or more indentation characters, and is not within an unquoted string that already contains one or more non-indentation characters.
%
%When the top level of a dataset is a list, there is no need to indent a plus sign that starts an element, since there is no pre-existing indentation level relative to which to indent.
%
%The first non-indentation character after the plus sign sets the indentation level of the list item content.  All content must be indented based on this level.
%
%Logical choices for the beginning-of-list character are the plus |+|, hyphen |-|, and asterisk |*|.  The asterisk would be ideal, since it resembles a bullet point.  However, it is in common use in markup languages to denote italic/bold (emph/strong), so it may be expected at the beginning of a string.  While it would typically not appear at the beginning of a string with a following space (which could require quoting), its appearance could require that writers and readers take a second look to determine whether a list indeed starts.  That would add undesirable cognitive load.  A leading asterisk could also appear due pointers/dereferencing, etc.
%
%The hyphen is used by YAML and TOML.  Like the asterisk, it may be expected as a leading character in many cases.  It is used in command-line flags and as an ASCII approximation of an en dash or em dash.  A leading dash followed by a space is \href{https://en.wikipedia.org/wiki/Quotation_mark}{used in many languages to indicate quoting}, so that could also require additional escapes or cause confusion.  There is also the issue of visually distinguishing the hyphen from the various sorts of dash characters.  Finally, the hyphen does not have the same weight as the plus or asterisk, and thus is more easily overlooked.
%
%This leaves the plus sign for denoting list items.  The plus sign is not as commonly used in lightweight markup.\footnote{\href{http://orgmode.org/manual/Emphasis-and-monospace.html}{Org-mode} uses it as a strikethrough.}  In its mathematical and programming use, it rarely appears at the beginning of text.  It is more visible than the hyphen.  Unlike the asterisk and particularly the hyphen, there are not several other Unicode characters with a similar visual appearance.
%
%Using the plus sign for list items in indentation-based form also provides a nice parallel for dict keys and INI-style form.  In these cases, the notation |[+]| is used to refer to the next unused index in a specified list.
%
%
%
%
%\subsection{Quoted strings -- quotation marks (and trailing slash)}
%
%Most \bespon\ strings do not need to be quoted.  When strings are quoted, double and single typewriter quotation marks |"| and |'| (U+0022 and U+0027) are used.  The two types of quotation marks may be used interchangeably; if a string contains one type, then using the other for quoting is convenient.  The fullwidth quotation mark \begin{CJK*}{UTF8}{gkai}|＂|\end{CJK*} (U+FF02) and fullwidth apostrophe \begin{CJK*}{UTF8}{gkai}|＇|\end{CJK*} (U+FF07) may be used instead in CJK contexts.\footnote{Note that the fullwidth apostrophe will not necessarily resemble a fullwidth version of the single typewriter quotation mark in all fonts; in some fonts, it will appear curled.}
%
%There are two kinds of quoted strings.  An inline string begins with a group of one or more identical quotation marks, and continues until an identical group of quotation marks is encountered.  The closing group of quotation marks may not be bounded on either side by the type of quotation marks it contains.  If the first or last non-space (or non-ideographic space) character in a string is a quotation mark of the same type as used in the delimiters, then the outermost space character will be stripped.  Thus, |"'"| and |'' ' ''| would both represent the single quotation mark |'|.\footnote{If an inline string begins with a delimiter on one line, immediately followed by a newline so that the actual string content does not begin until the next line, then the newline is treated as a space if the content begins with the delimiter character.  The newline could not have been put there by a line-breaking algorithm, so it must have been entered by the user, and thus is equivalent to a space.  If the newline is preceded by a space, then it might have been entered by the user or produced by automatic hard wrapping.  Regardless, it will be stripped by all standard procedures for handling newlines, because it is preceded by a space.  And then the space will be stripped because of the presence of the delimiting character.  Essentially, everything proceeds as if the newline were not there, unless it is the only thing there and thus obviously came from the user.  Dealing with the equivalent case for the closing delimiter follows the same logic.  }
%
%An inline string may be broken across multiple lines.  In this case, all lines after the first line with the opening delimiter should have the same indentation.  All leading indentation on subsequent lines will be stripped.  No line except for the first line, after the opening delimiter, or the last line, before the closing delimiter, may consist solely of indentation characters and newlines.  The presence of a line of indentation characters in any other location must trigger an error.
%
%Any line breaks within an inline string are converted to spaces (U+0020), unless the preceding character is a space (U+0020) or ideographic space (U+3000), in which case they are stripped.  This means that if ideographic spaces are desired within inline strings, they must be entered explicitly at the ends of lines.  An inline string may span multiple lines, but the literal text it represents will always be a single line, without a final newline.
%
%A block string begins with a group of three or more identical quotation marks.  Nothing is allowed on the line after this opening delimiter except indentation characters.  The actual text follows on subsequent lines; any indentation characters and the line break following the opening delimiter do not contribute to the string.  The string ends when an identical group of quotation marks is encountered, unless the opening delimiter is preceded by only indentation characters, in which case the string does not end until a matching closing delimiter with the same indentation is found.  If a closing delimiter with the correct indentation is not found, then an error must be raised.  Ideally, the error will include the locations of delimiters that met the requirements except for indentation.  The ending quotation marks must be followed immediately by a slash |/| or fullwidth solidus \begin{CJK*}{UTF8}{gkai}|／|\end{CJK*}.  This allows the beginning and end of a block string to be easily distinguished, and provides a guaranteed difference from inline string notation.
%
%Within a block string, all line breaks are preserved.  The indentation level is set by the indentation level of the closing delimiter.  All lines of text within the block must be indented to at least the level of the closing delimiter, except those consisting solely of indentation characters and newlines; otherwise, an error must be raised.  All indentation shared with the closing delimiter is stripped.  The opening delimiter is only required to be at the same indentation level as the closing delimiter if the opening delimiter is on a line by itself, but having both delimiters share the same indentation is encouraged.  Since line breaks are preserved, the string will end with a newline.  If this is not desired, then an additional slash may be added to the closing delimiter, and the final newline will be stripped.  Newline type (|\n| vs. |\u2028|, etc.) should be conserved within block strings.
%
%The opening delimiter for both inline and block strings may be identical, though this should be rare in practice.  Typically, an inline string should need less than three quotation marks, and the opening quotation marks should almost always be followed on the same line by text.  In these cases, the difference between an inline and block string will be immediately apparent.  In the rare cases in which an inline string does use three or more quotation marks, it may always be distinguished from a block string by an absence of empty lines and by the absence of one or two slashes |/| after the closing delimiter.  Also, the closing delimiter for an inline string is not required to be the element on a line after indentation is stripped.
%
%Inline strings:
%\begin{Verbatim}
%'A single inline string'
%"A string that spans multiple lines
%but contains no newlines and doesn't end with a newline"
%\end{Verbatim}
%
%Block strings:
%\begin{Verbatim}
%'''
%A block string with newlines preserved
%and ending in a newline.
%'''/
%"""
%A block string not ending in a newline.
%"""//
%\end{Verbatim}
%
%Unlike unquoted strings, quoted strings that span multiple lines are not required to be indented relative to the parent element's indentation level, so long as the string does not begin on a line by itself.  For example,
%\begin{Verbatim}
%key = '''
%value that
%spans multiple lines
%'''/
%\end{Verbatim}
%This is valid so long as |key| and the opening |'''| are on the same line.  If the opening delimiter were on a line by itself, then it would have to be indented to the same level as the closing delimiter.  Indenting is encouraged for visual clarity, but it is not required.  Parsing is possible due to the delimiters, and in some cases it will be convenient not to have to indent.
%
%In some contexts (for example, streaming), it may be desirable to work with text that contains arbitrarily long runs of quotation marks.  In these cases, the opening delimiter should be placed on a line by itself, so that the indentation level of the closing delimiter is set.  Then the actual text may be indented by one or more characters relative to this, and this indentation stripped during processing.  For example,
%\begin{Verbatim}
%key =
% '''
%  '''
% '''/
%\end{Verbatim}
%
%
%Quoted inline and block strings are only some of the possible string types; others are discussed below.
%
%Note that mixing an ASCII quotation mark with its fullwidth equivalent in a string delimiter is allowed, since the two characters must be treated as equivalent.  Libraries must parse this case correctly.  However, actually mixing the two types of characters is extremely discouraged, and libraries may alternatively raise an error in this case, since this is the one case in which an exception to treating ASCII and fullwidth as equivalent is allowed.
%
%
%\subsection{Ending delimiters -- slash and fullwidth solidus}
%
%Slashes |/| (U+002F) (and fullwidth solidus \begin{CJK*}{UTF8}{gkai}|／|\end{CJK*} (U+FF0F) for CJK) only have a special meaning as part of the ending delimiters for multiline comments and block strings.  They distinguish the opening delimiters from the closing delimiters in these cases, by appearing as the last character in the closing delimiter.  This is reminiscent of the use of the slash in closing HTML tags.  In the multiline string case, the slash may be doubled to indicate that the final newline is stripped.
%
%
%\subsection{Collection datatypes and typing -- parentheses, fullwidth parentheses, greater-than sign, fullwidth greater-than sign, square brackets, fullwidth square brackets, curly braces, fullwidth curly braces}
%
%In compact form, collection datatypes are delimited by paired characters.  Lists are delimited by square brackets |[]| (U+005B and U+005D).  Dicts are delimited by curly braces |{}| (U+007B and U+007D).  Fullwidth versions may be used in CJK contexts.  Parentheses are reserved for delimiting special objects.\footnote{Parentheses are intended for a special dict-style object that is not required to be implemented.  In this object, all allowed keys are given default, pre-defined initial values upon initialization.  If a key is specified by name only, then it takes on a previously specified default value.  If a key-value pair is specified, then the key is mapped to that value.  Such objects are useful in configuration and are inspired by typical \LaTeX\ key-value packages.  They are also similar to some command-line flag parsers.}
%
%Deciding on criteria for quoting a string that contains parentheses/brackets/braces is difficult.  In compact notation, a string that begins with an opening character must be quoted, since otherwise a new object would be opened.  Symmetry would then suggest that an unquoted string may not begin with a closing character; in any case, in a typical syntax, an unquoted closing character would close an object.  Although this has been discussed in terms of compact notation, it also applies to non-compact notation, since non-compact notation may temporarily transition to compact notation at the beginning of any element.
%
%In terms of parsing for an object delimited by a given pair of characters, it would be possible to allow these characters within an unquoted string so long as they appear in pairs.  However, that would make parsing more complex.  It would also mean that the last character in an unquoted string could be identical to the following character, which closes the object.  For example, a list containing the string ``string[]'': |[string[]]|.  In such a situation, it could be necessary to glance at the entire unquoted string to determine whether all characters are paired, and which character actually closes the object.
%
%It would be possible to work around some of this by requiring that an unquoted string in compact form always end with a separator |;|.  Thus, the last example would become |[string[];]|.  It would be error-prone, since users expect a trailing separator to be optional.  In effect, this would be the opposite of the JSON trailing comma issue.  Given the excitement that has caused, it would be best not to replicate anything similar.
%
%The simplest solution would seem to be to require quoting any string that contains the characters used to delimit the current collection object.  Even this could be problematic, however.  A string that is perfectly valid in a list (no square brackets) would not be valid in a dict if it contains curly braces.  This suggests what might be called the \textit{principle of uniformity}:  An unquoted string must be valid in all contexts.
%
%
%Parentheses are also used to designate types beyond those that may be represented by standard syntax.  The syntax |(type)>| is used to designate the type of the following object.  Fullwidth parentheses and greater-than sign \begin{CJK*}{UTF8}{gkai}|＞|\end{CJK*} (U+FF1E) may be used with CJK characters.  Type designations must consist of characters that are not whitespace, parentheses, braces, brackets, quotation marks, percent signs, or semicolons; no whitespace is allowed between the parentheses, or between the closing parenthesis and the greater-than sign.\footnote{``Whitespace'' should be interpreted as Unicode characters with character property WSpace.}  A greater-than sign is not allowed after a parenthesis that closes a collection type.
%
%Explicit type declarations for collection types must be at the beginning of lines by themselves, with nothing following, in non-compact notation; they set the indentation level for the collection.  In compact notation, they must be followed by the corresponding opening brace or bracket, which must be on the same line unless already within compact notation.  Explicit type declarations for string-like types must be on the same line as the object to which they apply, unless in compact notation.
%
%\bespon\ specifies some types that must be implemented for |(type)>| syntax.  It also specifies several types that may optionally be implemented.  A library that does not implement these optional types must raise an error if they are encountered, or if any other unrecognized types are encountered.  All official types, both required and optional, are named with a |type.subtype.subsubtype| syntax.  In the future, a |type.subtype+subtype| or a |type.subtype=value| syntax may also be allowed.  All official types, both required and optional, will only use the following characters between the parentheses: |a-z|, |A-Z|, |0-9|, and the punctuation characters |+.:=,;_|.  The corresponding fullwidth characters must be treated as equivalent when performing type lookups.
%
%If explicit typing is in play, it overrides reserved words and default typing of unquoted strings.
%
%Libraries may implement types beyond those specified by \bespon.  These types should be named in |lib:type.subtype.subsubtype| form, where ``|lib|'' may be replaced with the library name or an abbreviation of it if desired.  Libraries may also implement hooks for user-defined types.  These should be named in the form |user:type.subtype.subsubtype| or |usr:type.subtype.subsubtype|.  |user| and |usr| should be accepted interchangeably.  This prevents library and user types from unintentionally colliding with official types.
%
%
%\subsection{Typing -- greater-than sign}
%
%The greater-than sign |>| (U+003E), and fullwidth equivalent \begin{CJK*}{UTF8}{gkai}|＞|\end{CJK*} (U+FF1E), is used in indicating typing when it immediately follows a set of parentheses that do not contain any whitespace or parentheses characters.
%
%
%\subsection{Separator -- semicolon and fullwidth semicolon}
%
%In compact syntax, individual items in a collection datatype are separated by semicolons |;| (U+003B).  For example, a list |[1; 2; 3]|.  The fullwidth semicolon \begin{CJK*}{UTF8}{gkai}|；|\end{CJK*} (U+FF1B) may be used in CJK contexts.
%
%Semicolons and commas are logical choices for item separators.  Semicolons were chosen because they appear less frequently in most text and programming contexts, and thus reduce the need for quoted strings.  They are also more visible than commas, which helps with identifying implicit empty strings.
%
%In compact syntax, when nothing precedes a separator, it represents the empty string.  For example, |[abc;;]| is a list with two elements, the string |abc| and the empty string.  The empty string may never be implied in compact syntax, so that the meaning of a separator |;| after the last element in a collection is not ambiguous.  Thus, |[abc;]| and |[abc]| are identical lists containing a single string.  The |;]| does not imply a second element containing the empty string.
%
%
%\subsection{Key-value assignment and INI-style form -- equals sign and fullwidth equals sign, and slash and fullwidth solidus}
%
%The equals sign |=| (U+003D) is used in key-value assignment.  For example, |key=value|.  The fullwidth equals sign \begin{CJK*}{UTF8}{gkai}|＝|\end{CJK*} (U+FF1D) may be used in CJK contexts.  The equals sign may be preceded or followed by indentation characters.  If the key contains whitespace or special characters that require quoting, then it must be quoted.  The equals sign must always be on the same line as the key.  Depending on context, the value may be on another line.
%
%The equals sign must only be recognized as the separator between a key-value pair (1) within a collection type that consists of key-value pairs (or in a context where such a collection type may begin), and (2) when it follows a properly quoted key, or when it is the first equals sign in a run of non-whitespace characters (optionally) followed by a run of indentation characters.  Any subsequent equals signs are never treated as key-value separators and need not be escaped, with the exception of equals signs that would make the value look like a key-value pair.
%
%In an indentation-sensitive context, the indentation level for |value| must be greater than the indentation level for the first letter of |key|.  If |value| is split over multiple lines, the first line upon which it appears after |key| sets the indentation level for subsequent lines, except in the case of quoted strings or similar elements that contain their indentation information in the closing delimiter.
%
%When an equals sign without preceding characters is encountered (for example, |=value|), it will be considered the separator between an empty string key and a value.  
%
%The sequence |===| is used to support an INI-style syntax when not in compact mode.  A line that begins with |===| (optionally preceded by indentation characters) must follow it with a path within the data serialization structure.  Everything following the line with the |===| will be assigned at this location.  For example, everything under the line |===key| would be under |key| in the dict at the current indentation level.  A location specified via the |===| syntax is in force until the next use of |===| at the same indentation level.  The special sequence |===/| ends all use of the INI-style syntax at the current indentation level.  The fullwidth solidus may be used in CJK contexts.  An element that is indented less than the opening |===| also ends all use of the INI-style syntax at the level of the |===|.  Uses of |===| at the same indentation level are not nested; using |===/| does not close the current INI-style block while leaving the previous block at the same indentation level open, but rather ends all INI-style syntax at the current indentation level.  Key paths specified via the |===| syntax are always relative to the current location and refer to locations at or below that location; there is not a syntax for root-based keys, or for specifying relative key levels above the current level.
%
%
%\subsection{Key paths -- period, fullwidth period, square brackets, fullwidth square brackets, plus sign, fullwidth plus sign, underscore, fullwidth low line}
%
%In a dict, standard keys set values.  \bespon\ also allows for ``compound'' keys that may be used in a dict to create a series of nested dicts and/or lists, only setting an actual value at the innermost level.  An unquoted key's string is split at periods |.| (U+002E) and fullwidth periods \begin{CJK*}{UTF8}{gkai}|．|\end{CJK*} (U+FF0E).  Each element in the resulting list is treated as a key to a series of nested dicts.  Any key that ends with square brakets |[]| (U+005B and U+005D), or the fullwidth equivalent \begin{CJK*}{UTF8}{gkai}|［］|\end{CJK*} (U+FF3B and U+FF3D), containing an integer (in ASCII or fullwidth equivalent), is treated as an index in a list.  The square brackets need not be separated from previous elements by a period; |key1.key2[0]| and |key1.key2.[0]| are treated as equivalent.  The unquoted string |key1.key2[0]=value| would create a key |key1| in the current dict, mapped to a dict in which |key2| is associated with a list, in which the first (zeroth) element is |value|.
%
%An unquoted key must be a valid unquoted string.  In addition, it may not contain Unicode whitespace, and the first character in each element of the key path must not be a Unicode number.  This guarantees that key path elements are distinct from integers and floating point numbers.  Literal integers and floating point numbers are not allowed in unquoted key paths; implementations may, however, allow them as individual keys.
%
%When keys refer to lists, the lists are always zero-indexed.  When a list is assembled piece by piece, the special notation |[+]| may be used to refer to the next unused index in the list (that is, to append an element).  The notations |[-1]| may be used to refer to the last element.  A trailing pair of square brackets only needs to be escaped when it contains an integer or a plus sign.  Negative indices are treated as in Python.
%
%A key that begins with a list index (for example, |[0].subkey|) is invalid by default, because dicts only accept keys that are strings, integers, or floats.  This is treating the current dict as containing a key |[0]|, which could be interpreted as a list containing only |[0]|, or alternatively as indexing into an ordered dict.  Neither are allowed by default.
%
%When working with key paths two or more levels deep, the underscore character |_| (U+005F) or fullwidth low line \begin{CJK*}{UTF8}{gkai}|＿|\end{CJK*} (U+FF3F), when followed immediately by a period or by square brackets that index a list, refers to the last used key path, with the last element removed.  This allows more compact notation.  For example,
%\begin{Verbatim}
%complex_key.property[+] = 1
%_[+] = 2
%_[+] = 3
%\end{Verbatim}
%would be equivalent to the JSON
%\begin{Verbatim}
%{"complex_key": {"property": [1, 2, 3]} }
%\end{Verbatim}
%The underscore does not refer to the full path, because typically the final element will be fully assigned.  A literal underscore may be obtained by quoting when this shorthand notation is not desired.  When using the |===| syntax, the underscore |_| refers to the key path of the last usage of the syntax at the current indentation level, with the last element removed.
%
%Note that the period and underscore only have special meaning when they occur within a key path.  In no other situation, particularly in unquoted strings, do they require any special treatment or escaping.
%
%The unquoted slash |/| may not be used as the first character in a key path, unless it is the only character.
%
%
%
%\section{Basic types}
%
%\bespon\ defines a number of basic types that must be implemented by a fully comforming library.  These types are available without any manual specification of type information.
%
%\subsection{String}
%
%Since \bespon\ is designed for working with literal text, these are of primary importance.  Default strings are pure Unicode string literals, with no escapes of any sort.
%
%Unquoted strings must meet certain requirements in order to avoid the need for quoting.  These are stricter than would be strictly necessary to avoid quoting.  They are based on the \textit{principle of uniformity}:  An unquoted string should be valid in all forms of \bespon\ syntax, and should not result in a syntax error or undesired data structure if it were copied to another collection type or put on a line by itself and indented relative to the parent element.
%\begin{itemize}
%\item Must not begin with parentheses |()|, curly braces |{}|, or square brackets |[]|.  Must not contain an unmatched pair of any of these characters.  An implementation must support these characters in nested pairs up to a total of three levels deep, and may raise an implementation-unsupported error for additional levels (upon encountering an opening character that would open a fourth level).  \textit{A beginning character would signal the closing of the current collection object (in compact notation) or the opening of a new object, or (for parentheses) an explicit type declaration.  In compact notation, unpaired internal characters would prematurely close the object or make the end of the object impossible to find if terminated by a closing character rather than a semicolon}|;|\textit{.  The requirement that internal characters be paired is necessary in compact form, but is more than would be strictly necessary otherwise.  Likewise, requiring all characters to be paired is a broader requirement than is strictly necessary within any one collection object delimited by a single set of these characters.  However, it is applied in all cases for overall simplicity and uniformity.}
%\item Must not begin with quotation marks |'| or |"|.  \textit{This would indicate a quoted string, or a quoted portion of a key.}
%\item Must not begin with an equals sign |=|, or have an equals sign separated from the beginning of the string by a single group of non-whitespace characters optionally followed by a single group of whitespace characters.  \textit{The beginning of a string cannot appear to be a key-value pair with an unquoted key.  In most situations, this case could actually be parsed correctly.  However, in the event of improper hard-wrapping in non-compact syntax, it is easily prone to errors.  It also presents the visual appearance of ambiguity, even if ambiguity does not actual exist.  }|key = value = and equals|\textit{ just looks like some sort of special object.}
%\item Must not begin with a plus sign |+| followed by an indentation character or whitespace.  \textit{This would make it look like the beginning of a list item in non-compact form.  Putting the string on a new line, indented from the parent element, would actually start a list.}
%\item Must not contain a percent sign |%|.  \textit{It would be possible to treat an unquoted string like a quoted string, in the sense that once it begins, all characters except those strictly required to end it are disabled.  However, that would make it impossible to have a comment after anything unquoted, including booleans and numbers, and that is unacceptable.}
%\item Must not contain a semicolon |;|.  \textit{This is only strictly necessary in non-compact syntax.  However, it ensures that transitioning between the two will require no modifications.}
%\item Must not fit a pattern that would cause it to be identified with an implicit literal (integer, float, null, boolean).
%\end{itemize}
%
%Unquoted strings may break over multiple lines, but subsequent lines must be indented relative to the parent element.  That is, all lines of a wrapped unquoted string should have the same indentation level in a list, but should be indented relative to the key when serving as the value in a key-value pair.  Unquoted strings may not contain lines consisting only of whitespace characters.  Leading and trailing whitespace characters will be stripped, and each newline will be converted to a space if not preceded by a space or ideographic space, in which case it will be stripped.\footnote{It would be tempting to deal with newlines as in \href{https://www.ietf.org/rfc/rfc2646.txt}{RFC 2646}, either in inline strings or perhaps in a wrapping mode with block strings.  However, that could make \bespon\ less easy to edit; it is very easy to go on to the next line without leaving a trailing space.  The current scheme will give reasonable behavior in the majority of cases.  Explicit entry of an ideographic space, or escaped strings with escaped newlines, can always be used to work around the default unwrapping.}
%
%Quoted strings come in inline and block forms as already described.
%
%
%\subsection{Null}
%
%Any unquoted string consisting solely of |null| will be converted to null.
%
%
%\subsection{Boolean}
%
%Any unquoted string consisting solely of |true| or |false| will be converted to the corresponding boolean.
%
%
%\subsection{Integer}
%
%Any unquoted string consisting solely of characters that may be interpreted as an integer.  The string representation of an integer cannot involve scientific notation or a decimal point; otherwise, it will be interpreted as a float.
%
%Languages that have an integer type should interpret integers as signed integers or a compatible type.  Languages without an integer type should interpret them as floats.  At a minimum, support for IEEE 754 binary64 floats is expected.  Regardless of the type used, any conversion from string that results in an overflow must result in an error.
%
%Care should be taken when using integer values whose float representation cannot fit within an IEEE 754 binary64 float, since some languages such as JavaScript only have a 64-bit float number type.
%
%A language that does not have an integer type may send \bespon\ integers.  However, care should be taken that an integer is actually intended, since in some languages such as JavaScript the default string representation of a float with no decimal part will be a \bespon\ integer.
%
%
%\subsection{Float}
%
%Any unquoted string consisting solely of characters that may be interpreted as a float.  
%
%At a minimum, support for IEEE 754 binary64 floats is expected.  Regardless of the type used, any conversion from string that results in an overflow must result in an error.
%
%Any string consisting solely of |inf|, with or without a sign, or of |nan| will be converted to the corresponding float value.
%
%
%\subsection{List}
%
%An ordered collection of elements.  In compact syntax, delimited by square brackets |[]| with each element separated by semicolons |;|.  Otherwise, indicated by an indented plus sign |+| followed by one or more indentation characters.  May also be indicated via key path syntax, with index enclosed in square brackets |[]|.
%
%Regardless of the actual underlying implementation, lists behave as if they can be accessed by index and allow appending.  They behave as Python lists.  Lists may contain elements of multiple types.
%
%
%\subsection{Dict}
%
%A mapping of keys to values, typically unordered.  String keys must be supported.  Libraries are encouraged to support all non-collection basic types (null, booleans, integers, floats) as keys to provide better serialization support, but this is not required.  With appropriate languages, libraries may also support other types.  However, the use of non-string keys is discouraged, particularly when \bespon\ is being used to pass data between different languages.  Floats are typically unsuitable as keys, since they may experience rounding errors on round-tripping.  Also, some languages treat non-string keys in a manner that could produce unexpected results.  For example, Python does not distinguish between integer and float keys when the two represent the same number (for example, |1.0| vs.\ |1|), and \href{http://php.net/manual/en/language.types.array.php}{PHP apparently typecasts} null, bool, and float keys to string or int.  Collection objects are not allowed as keys because they would conflict with key path syntax, and because collection objects are often mutable and thus potentially problematic as keys.
%
%A library must raise an error if it encounters a key type that it does not support.
%
%When saving dicts to file, libraries should sort the keys by binary representation when expressed in \bespon\ form and then encoded in UTF-8.  This provides a fixed key order that makes file diffs meaningful.  A library may instead sort the Unicode strings, but since this is locale-dependent and needs to account for Unicode normalization, it is discouraged in the general case.
%
%
%
%\section{Extended types}
%
%\bespon\ defines extended types that must be implemented by a fully conforming library.  These types are only available with manual specification of type information.
%
%
%\subsection{Escaped string}
%
%Designated by |(str.esc)>|, and the short form |(esc)>|.  Parsed like a normal string, with or without quoting; escaping is only performed after the string has been extracted.  This means that a string delimited by double quotation marks |"""| cannot end with |\""""|, since the escaped quotation mark would be seen as part of the closing delimiter (escaping is only applied after the string is parsed).  Rather, |\" """| would be required.  The space after |\"| would be stripped, following the standard rules for quoted strings.  Ideally, escaping should be able to be combined with other string types using |(str.subtype+esc)>| syntax.  Note that escaping must always be performed after all unwrapping operations (used in parsing inline strings).  In general, it should be the final step in handling a string.
%
%All characters that are not allowed to appear literally within a \bespon\ file must be represented in escaped form: |\xHH| (8-bit), |\uHHHH| (16-bit), and |\UHHHHHHHH| (32-bit) hex notation.  The shorthand sequences |\\|, |\'|, |\"|, |\a|, |\b|, |\e|, |\f|, |\n|, |\r|, |\t|, |\v| are also allowed.  All of these should be accepted in incoming data; |\e| should typically be avoided in outgoing data, since its use is less common.  A backslash followed by zero or more spaces or ideographic spaces, followed by a literal newline is treated as a line continuation, and stripped.  For situations in which JSON compatibility is desirable, the escape |\/| should also be allowed in incoming data.  A library should recognize all of the short escaped forms in reading, but may optionally use |\x|, |\u|, or |\U| forms instead in text it emits.  It may also use only a subset of the allowed short escapes.\footnote{If additional shorthand escapes are used, the character after the backslash should be restricted to |\x21| through |\x7E|, that is, printable ASCII less the space, which is (optionally) part of escaping newlines.}
%
%A library may parse escapes in a sloppy manner, in which unknown shorthand escapes become literal slashes followed by literal characters.  However, strict parsing, in which only known escapes are recognized and literal slashes are only produced by |\\|, is encouraged.
%
%\subsection{Empty string}
%
%Designated by |(str.empty)>|.  Serves as a visual marker for an implicit empty string that could otherwise be difficult to see.
%
%When the empty string is not designated via explicit typing, it must be treated carefully, particularly when it is the only thing in a file.  A completely empty file does not represent the empty string; a file must contain one or more whitespace characters to represent the empty string.  These characters must not be indentation characters before the beginning of a comment, or whitespace characters after the end of a multi-line comment.  For a whitespace character to represent the empty string in a file that only contains the empty string, the whitespace character must be on a line by itself.  Typically, this will mean one or more spaces, tabs, or newlines after the newline that ends any opening comments.
%
%
%
%
%
%\section{Optional types}
%
%These types are completely optional.  Most will likely not be implemented by a typical library.
%
%\subsection{Binary}
%
%All binary types may be collected as unquoted strings, or as quoted inline or block strings.  
%
%|(bin)>| designates binary represented with printable US ASCII characters and escapes |\xHH| (plus short escapes).  It corresponds to Python's bytes type.  Note that implicit newlines in multiline strings will be those contained in the source, with the exception that U+2028 and U+2029 should be converted to |\n|.  |(bin.empty)>| is used to mark an implicit empty binary string.
%
%|(bin.unwrap)>| and |(bin.xunwrap)>| correspond to the equivalent |str| types.
%
%|(bin.base64)>| and the short form |(bin.b64)>| designates RFC 3548 Base64.  The content should be quoted since equals signs will typically be involved.
%
%|(bin.base16)>| (aliases |(bin.hex)>| and |(bin.b16)>|) designates hexadecimal.  Quoting is allowed but not necessary.
%
%|(bin.raw)>| is reserved for a possible binary \bespon\ variant in the future.
%
%\subsection{Ordered dict}
%
%Designated by |(odict)>|.
%
%\subsection{Set}
%
%Designated by |(set)>|.
%
%\subsection{Tuple}
%
%Designated by |(tuple)>|.
%
%
%\subsection{Array}
%
%Designated by |(array)>|.
%
%\subsection{Datetime}
%
%Designated by |(datetime)>|.  Parses a quoted or unquoted string with the RFC 3339 spec.
%
%\subsection{IEEE 754}
%
%Designated by |(float.binary32)>|, |(float.binary64)>|, |(float.binary128)>|, and by |(float.decimal64)>| and |(float.decimal128)>|.  For the binary formats, numbers must always be stored in \bespon\ files in hexadecimal form, to prevent rounding errors.  |binary| may be abbreviated to |b| and |decimal| to |d|.  Arrays of a given type may be specified via |(array.float.binary32)>| before the array, etc.
%
%\subsection{Arbitrary precision arithmetic}
%
%Designated by |(int.arb)>|, |(float.binaryarb)>| and |(int.decimalarb)>|.  |binary| may be abbreviated to |b| and |decimal| to |d|.  Binary floats must be stored in hexadecimal form to prevent rounding errors.
%
%\subsection{Copying}
%
%With |(copy)>|, a following string is used as a key path, starting at the current level.  The element pointed to by this path is shallow copied.  |(deepcopy)>| may be used for deep copies.  The syntax |/<key>.<key>| may be used to refer to the root.  The syntax |../../<key>.<key>| may be used to specify relative paths at a higher level.  All syntax following the last slash is normal dot-separated key syntax; all dots preceding the last slash are interpreted as part of the unit |../| rather than separators for null string keys.
%
%Note:  It may be worth considering a reference syntax |(ref)>|, which provides a reference rather than performing some type of copy.
%
%\subsection{Special data}
%
%The following are used for designating special dicts.  They may only be used at the very beginning of a \bespon\ file; this simplifies parsing.  The dicts designated with these types are not returned as part of the main dataset.  Libraries should provide access to them in another manner, perhaps by wrapping the main dataset in an object with these as some of the properties.
%
%\subsubsection{Templating}
%
%|(template.var)>| is used to designate a dict that contains key-value pairs that may be substituted into strings.  All values must be strings.  This must come before any actual substitution; otherwise, an error must be raised.  |(str.template)>| is used to indicate that a given string should be treated as a template.  Default syntax is |${var}| style, with the braces optional, and doubled dollar sign |$$| for escaping.  %$ <- syntax highlighting
%
%\subsubsection{Metadata}
%
%Metadata may be specified in a dict following |(meta)>|.
%
%\subsubsection{Schema}
%
%There is not currently a schema system for \bespon\ files.  If one is created, schemas may be references or included within a \bespon\ file under |(schema)>|.
%
%
%
%\section{Data dumping}
%
%Because \bespon\ offers three data formats, there is a multitude of ways that even a simple dataset might be represented in \bespon\ format.
%
%Libraries must provide options to serialize data entirely in compact form or in indentation-based form.  They may also provide an option to use only INI-style form, although only using this form may be unnecessarily verbose; it may also be less than ideal in other respects.
%
%Libraries are encouraged to provide a way to load data, modify it, and then save it, all while maintaining its formatting and all comments.  However, given the added level of complexity that this entails, this is not required.  \bespon\ should be thought of first and foremost as a convenient way for humans to get configuration data into computers, rather than a way for computers to rewrite humans' data while keeping the formatting just so.  Libraries are also encouraged to provide relatively granular control over the specific form in which data is saved, for working with computer-generated data.
%
%



\pagebreak
\begin{appendices}

Below, JSON, YAML, and TOML examples are provided with corresponding \bespon\ representations.

The JSON example is from \href{https://en.wikipedia.org/wiki/JSON}{Wikipedia}.  The YAML example is also from \href{https://en.wikipedia.org/wiki/YAML}{Wikipedia}.  The TOML example is from the \href{https://github.com/toml-lang/toml}{TOML GitHub page}.


\section{Inline form}


\begin{tcolorbox}{}
\begin{multicols}{2}

\centering \textbf{JSON}
\begin{Verbatim}[formatcom=\color{DarkGreen}]
{
  "firstName": "John",
  "lastName": "Smith",
  "age": 25,
  "address": {
    "streetAddress": "21 2nd Street",
    "city": "New York",
    "state": "NY",
    "postalCode": "10021"
  },
  "phoneNumber": [
    {
      "type": "home",
      "number": "212 555-1234"
    },
    {
      "type": "fax",
      "number": "646 555-4567"
    }
  ],
  "gender": {
    "type": "male"
  }
}
\end{Verbatim}
\columnbreak
\centering \textbf{BespON}

\begin{Verbatim}
{
  firstName = John,
  lastName = Smith,
  age = 25,
  address = {
    streetAddress = 21 2nd Street,
    city = New York,
    state = NY,
    postalCode = '10021'
  },
  phoneNumber = [
    {
      type = home,
      number = 212 555-1234
    },
    {
      type = fax,
      number = 646 555-4567
    }
  ],
  gender = {
    type = male
  }
}
\end{Verbatim}
\end{multicols}
\end{tcolorbox}



\section{Indentation-based form}


\begin{tcolorbox}{}
\fvset{fontsize=\footnotesize}
\begin{multicols}{2}

\centering \textbf{YAML}
\begin{Verbatim}[formatcom=\color{DarkGreen}]
---
receipt:     Oz-Ware Purchase Invoice
date:        2012-08-06
customer:
    first_name:   Dorothy
    family_name:  Gale

items:
    - part_no:   A4786
      descrip:   Water Bucket (Filled)
      price:     1.47
      quantity:  4

    - part_no:   E1628
      descrip:   High Heeled "Ruby" Slippers
      size:      8
      price:     133.7
      quantity:  1

bill-to:  &id001
    street: |
            123 Tornado Alley
            Suite 16

    city:   East Centerville
    state:  KS

ship-to:  *id001

specialDelivery:  >
    Follow the Yellow Brick
    Road to the Emerald City.
    Pay no attention to the
    man behind the curtain.
...
\end{Verbatim}
\columnbreak
\centering \textbf{BespON}

\begin{Verbatim}

receipt =     Oz-Ware Purchase Invoice
date =        2012-08-06
customer =
    first_name =   Dorothy
    family_name =  Gale

items =
    * part_no =   A4786
      descrip =   'Water Bucket (Filled)'
      price =     1.47
      quantity =  4

    * part_no =   E1628
      descrip =   'High Heeled "Ruby" Slippers'
      size =      8
      price =     133.7
      quantity =  1

bill-to = 
    street = '''
             123 Tornado Alley
             Suite 16
             '''/
    city =   East Centerville
    state =  KS

ship-to = (alias.path)> bill-to

specialDelivery = 
    Follow the Yellow Brick
    Road to the Emerald City.
    Pay no attention to the
    man behind the curtain.

\end{Verbatim}
\end{multicols}
\end{tcolorbox}
The |specialDelivery| isn't quite the same as YAML, because YAML will have a final linebreak.



\begin{tcolorbox}{}
\fvset{fontsize=\footnotesize}
\begin{multicols}{2}

\centering \textbf{TOML}
\begin{Verbatim}[formatcom=\color{DarkGreen}]
# This is a TOML document.

title = "TOML Example"

[owner]
name = "Tom Preston-Werner"
dob = 1979-05-27T07:32:00-08:00

[database]
server = "192.168.1.1"
ports = [ 8001, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

  [servers.alpha]
  ip = "10.0.0.1"
  dc = "eqdc10"

  [servers.beta]
  ip = "10.0.0.2"
  dc = "eqdc10"

[clients]
data = [ ["gamma", "delta"], [1, 2] ]

# Line breaks are OK when inside arrays
hosts = [
  "alpha",
  "omega"
]
\end{Verbatim}
\columnbreak
\centering \textbf{BespON}

\begin{Verbatim}
% This is a BespON document.

title = BespON Example

owner =
  name = Geoffrey Poore
  dob = <some number>

database =
  server = '192.168.1.1'
  ports = [8001, 8001, 8002]
  connection_max = 5000
  enabled = true

servers =

  alpha = 
    ip = '10.0.0.1'
    dc = eqdc10

  beta =
    ip = '10.0.0.2'
    dc = eqdc10

clients =
  data = [ [gamma, delta], [1, 2] ]

% Line breaks are generally OK
hosts = [
  alpha,
  omega
]
\end{Verbatim}
\end{multicols}
\end{tcolorbox}



\section{Section-style form}




\begin{tcolorbox}{}
\fvset{fontsize=\footnotesize}
\begin{multicols}{2}

\centering \textbf{YAML}
\begin{Verbatim}[formatcom=\color{DarkGreen}]
---
receipt:     Oz-Ware Purchase Invoice
date:        2012-08-06
customer:
    first_name:   Dorothy
    family_name:  Gale

items:
    - part_no:   A4786
      descrip:   Water Bucket (Filled)
      price:     1.47
      quantity:  4

    - part_no:   E1628
      descrip:   High Heeled "Ruby" Slippers
      size:      8
      price:     133.7
      quantity:  1

bill-to:  &id001
    street: |
            123 Tornado Alley
            Suite 16
    
    city:   East Centerville
    state:  KS

ship-to:  *id001

specialDelivery:  >
    Follow the Yellow Brick
    Road to the Emerald City.
    Pay no attention to the
    man behind the curtain.
...
\end{Verbatim}
\columnbreak
\centering \textbf{BespON}

\begin{Verbatim}

receipt =    Oz-Ware Purchase Invoice
date =       2012-08-06
=== customer
first_name =  Dorothy
family_name = Gale

=== items
* part_no =  A4786
  descrip =  'Water Bucket (Filled)'
  price =    1.47
  quantity = 4

* part_no =  E1628
  descrip =  'High Heeled "Ruby" Slippers'
  size =     8
  price =    133.7
  quantity = 1

=== bill-to
street = '''
         123 Tornado Alley
         Suite 16
         '''/
city =  East Centerville
state = KS
===/
ship-to = (alias.path)> bill-to

specialDelivery =
    Follow the Yellow Brick
    Road to the Emerald City.
    Pay no attention to the
    man behind the curtain.

\end{Verbatim}
\end{multicols}
\end{tcolorbox}



\begin{tcolorbox}{}
\fvset{fontsize=\footnotesize}
\begin{multicols}{2}

\centering \textbf{TOML}
\begin{Verbatim}[formatcom=\color{DarkGreen}]
# This is a TOML document.

title = "TOML Example"

[owner]
name = "Tom Preston-Werner"
dob = 1979-05-27T07:32:00-08:00

[database]
server = "192.168.1.1"
ports = [ 8001, 8001, 8002 ]
connection_max = 5000
enabled = true

[servers]

  [servers.alpha]
  ip = "10.0.0.1"
  dc = "eqdc10"

  [servers.beta]
  ip = "10.0.0.2"
  dc = "eqdc10"

[clients]
data = [ ["gamma", "delta"], [1, 2] ]

# Line breaks are OK when inside lists
hosts = [
  "alpha",
  "omega"
]
\end{Verbatim}
\columnbreak
\centering \textbf{BespON}

\begin{Verbatim}
% This is a BespON document.

title = BespON Example

=== owner
name = Geoffrey Poore
dob = <some number>

=== database
server = '192.168.1.1'
ports = [ 8001, 8001, 8002 ]
connection_max = 5000
enabled = true

=== servers.alpha
ip = 10.0.0.1
dc = eqdc10

=== _.beta
ip = '10.0.0.2'
dc = eqdc10

=== clients.data
[ [gamma; delta]; [1; 2] ]

=== _.hosts
% Line breaks are generally OK
[
  alpha,
  omega
]
\end{Verbatim}
\end{multicols}
\end{tcolorbox}



\end{appendices}

\end{document}

